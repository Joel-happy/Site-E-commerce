
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model adresse
 * 
 */
export type adresse = $Result.DefaultSelection<Prisma.$adressePayload>
/**
 * Model choisit
 * 
 */
export type choisit = $Result.DefaultSelection<Prisma.$choisitPayload>
/**
 * Model client
 * 
 */
export type client = $Result.DefaultSelection<Prisma.$clientPayload>
/**
 * Model commande
 * 
 */
export type commande = $Result.DefaultSelection<Prisma.$commandePayload>
/**
 * Model facture
 * 
 */
export type facture = $Result.DefaultSelection<Prisma.$facturePayload>
/**
 * Model inclut
 * 
 */
export type inclut = $Result.DefaultSelection<Prisma.$inclutPayload>
/**
 * Model methodedepaiement
 * 
 */
export type methodedepaiement = $Result.DefaultSelection<Prisma.$methodedepaiementPayload>
/**
 * Model motos
 * 
 */
export type motos = $Result.DefaultSelection<Prisma.$motosPayload>
/**
 * Model panier
 * 
 */
export type panier = $Result.DefaultSelection<Prisma.$panierPayload>
/**
 * Model utilise
 * 
 */
export type utilise = $Result.DefaultSelection<Prisma.$utilisePayload>
/**
 * Model motossurcommande
 * 
 */
export type motossurcommande = $Result.DefaultSelection<Prisma.$motossurcommandePayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Adresses
 * const adresses = await prisma.adresse.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Adresses
   * const adresses = await prisma.adresse.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.adresse`: Exposes CRUD operations for the **adresse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Adresses
    * const adresses = await prisma.adresse.findMany()
    * ```
    */
  get adresse(): Prisma.adresseDelegate<ExtArgs>;

  /**
   * `prisma.choisit`: Exposes CRUD operations for the **choisit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Choisits
    * const choisits = await prisma.choisit.findMany()
    * ```
    */
  get choisit(): Prisma.choisitDelegate<ExtArgs>;

  /**
   * `prisma.client`: Exposes CRUD operations for the **client** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clients
    * const clients = await prisma.client.findMany()
    * ```
    */
  get client(): Prisma.clientDelegate<ExtArgs>;

  /**
   * `prisma.commande`: Exposes CRUD operations for the **commande** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Commandes
    * const commandes = await prisma.commande.findMany()
    * ```
    */
  get commande(): Prisma.commandeDelegate<ExtArgs>;

  /**
   * `prisma.facture`: Exposes CRUD operations for the **facture** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Factures
    * const factures = await prisma.facture.findMany()
    * ```
    */
  get facture(): Prisma.factureDelegate<ExtArgs>;

  /**
   * `prisma.inclut`: Exposes CRUD operations for the **inclut** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Incluts
    * const incluts = await prisma.inclut.findMany()
    * ```
    */
  get inclut(): Prisma.inclutDelegate<ExtArgs>;

  /**
   * `prisma.methodedepaiement`: Exposes CRUD operations for the **methodedepaiement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Methodedepaiements
    * const methodedepaiements = await prisma.methodedepaiement.findMany()
    * ```
    */
  get methodedepaiement(): Prisma.methodedepaiementDelegate<ExtArgs>;

  /**
   * `prisma.motos`: Exposes CRUD operations for the **motos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Motos
    * const motos = await prisma.motos.findMany()
    * ```
    */
  get motos(): Prisma.motosDelegate<ExtArgs>;

  /**
   * `prisma.panier`: Exposes CRUD operations for the **panier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Paniers
    * const paniers = await prisma.panier.findMany()
    * ```
    */
  get panier(): Prisma.panierDelegate<ExtArgs>;

  /**
   * `prisma.utilise`: Exposes CRUD operations for the **utilise** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Utilises
    * const utilises = await prisma.utilise.findMany()
    * ```
    */
  get utilise(): Prisma.utiliseDelegate<ExtArgs>;

  /**
   * `prisma.motossurcommande`: Exposes CRUD operations for the **motossurcommande** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Motossurcommandes
    * const motossurcommandes = await prisma.motossurcommande.findMany()
    * ```
    */
  get motossurcommande(): Prisma.motossurcommandeDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.12.1
   * Query Engine version: 473ed3124229e22d881cb7addf559799debae1ab
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    adresse: 'adresse',
    choisit: 'choisit',
    client: 'client',
    commande: 'commande',
    facture: 'facture',
    inclut: 'inclut',
    methodedepaiement: 'methodedepaiement',
    motos: 'motos',
    panier: 'panier',
    utilise: 'utilise',
    motossurcommande: 'motossurcommande'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'adresse' | 'choisit' | 'client' | 'commande' | 'facture' | 'inclut' | 'methodedepaiement' | 'motos' | 'panier' | 'utilise' | 'motossurcommande'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      adresse: {
        payload: Prisma.$adressePayload<ExtArgs>
        fields: Prisma.adresseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.adresseFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$adressePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.adresseFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$adressePayload>
          }
          findFirst: {
            args: Prisma.adresseFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$adressePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.adresseFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$adressePayload>
          }
          findMany: {
            args: Prisma.adresseFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$adressePayload>[]
          }
          create: {
            args: Prisma.adresseCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$adressePayload>
          }
          createMany: {
            args: Prisma.adresseCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.adresseDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$adressePayload>
          }
          update: {
            args: Prisma.adresseUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$adressePayload>
          }
          deleteMany: {
            args: Prisma.adresseDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.adresseUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.adresseUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$adressePayload>
          }
          aggregate: {
            args: Prisma.AdresseAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAdresse>
          }
          groupBy: {
            args: Prisma.adresseGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AdresseGroupByOutputType>[]
          }
          count: {
            args: Prisma.adresseCountArgs<ExtArgs>,
            result: $Utils.Optional<AdresseCountAggregateOutputType> | number
          }
        }
      }
      choisit: {
        payload: Prisma.$choisitPayload<ExtArgs>
        fields: Prisma.choisitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.choisitFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$choisitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.choisitFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$choisitPayload>
          }
          findFirst: {
            args: Prisma.choisitFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$choisitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.choisitFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$choisitPayload>
          }
          findMany: {
            args: Prisma.choisitFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$choisitPayload>[]
          }
          create: {
            args: Prisma.choisitCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$choisitPayload>
          }
          createMany: {
            args: Prisma.choisitCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.choisitDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$choisitPayload>
          }
          update: {
            args: Prisma.choisitUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$choisitPayload>
          }
          deleteMany: {
            args: Prisma.choisitDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.choisitUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.choisitUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$choisitPayload>
          }
          aggregate: {
            args: Prisma.ChoisitAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateChoisit>
          }
          groupBy: {
            args: Prisma.choisitGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ChoisitGroupByOutputType>[]
          }
          count: {
            args: Prisma.choisitCountArgs<ExtArgs>,
            result: $Utils.Optional<ChoisitCountAggregateOutputType> | number
          }
        }
      }
      client: {
        payload: Prisma.$clientPayload<ExtArgs>
        fields: Prisma.clientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.clientFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$clientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.clientFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$clientPayload>
          }
          findFirst: {
            args: Prisma.clientFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$clientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.clientFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$clientPayload>
          }
          findMany: {
            args: Prisma.clientFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$clientPayload>[]
          }
          create: {
            args: Prisma.clientCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$clientPayload>
          }
          createMany: {
            args: Prisma.clientCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.clientDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$clientPayload>
          }
          update: {
            args: Prisma.clientUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$clientPayload>
          }
          deleteMany: {
            args: Prisma.clientDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.clientUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.clientUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$clientPayload>
          }
          aggregate: {
            args: Prisma.ClientAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateClient>
          }
          groupBy: {
            args: Prisma.clientGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ClientGroupByOutputType>[]
          }
          count: {
            args: Prisma.clientCountArgs<ExtArgs>,
            result: $Utils.Optional<ClientCountAggregateOutputType> | number
          }
        }
      }
      commande: {
        payload: Prisma.$commandePayload<ExtArgs>
        fields: Prisma.commandeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.commandeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$commandePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.commandeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$commandePayload>
          }
          findFirst: {
            args: Prisma.commandeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$commandePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.commandeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$commandePayload>
          }
          findMany: {
            args: Prisma.commandeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$commandePayload>[]
          }
          create: {
            args: Prisma.commandeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$commandePayload>
          }
          createMany: {
            args: Prisma.commandeCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.commandeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$commandePayload>
          }
          update: {
            args: Prisma.commandeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$commandePayload>
          }
          deleteMany: {
            args: Prisma.commandeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.commandeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.commandeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$commandePayload>
          }
          aggregate: {
            args: Prisma.CommandeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCommande>
          }
          groupBy: {
            args: Prisma.commandeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CommandeGroupByOutputType>[]
          }
          count: {
            args: Prisma.commandeCountArgs<ExtArgs>,
            result: $Utils.Optional<CommandeCountAggregateOutputType> | number
          }
        }
      }
      facture: {
        payload: Prisma.$facturePayload<ExtArgs>
        fields: Prisma.factureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.factureFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$facturePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.factureFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$facturePayload>
          }
          findFirst: {
            args: Prisma.factureFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$facturePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.factureFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$facturePayload>
          }
          findMany: {
            args: Prisma.factureFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$facturePayload>[]
          }
          create: {
            args: Prisma.factureCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$facturePayload>
          }
          createMany: {
            args: Prisma.factureCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.factureDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$facturePayload>
          }
          update: {
            args: Prisma.factureUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$facturePayload>
          }
          deleteMany: {
            args: Prisma.factureDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.factureUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.factureUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$facturePayload>
          }
          aggregate: {
            args: Prisma.FactureAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFacture>
          }
          groupBy: {
            args: Prisma.factureGroupByArgs<ExtArgs>,
            result: $Utils.Optional<FactureGroupByOutputType>[]
          }
          count: {
            args: Prisma.factureCountArgs<ExtArgs>,
            result: $Utils.Optional<FactureCountAggregateOutputType> | number
          }
        }
      }
      inclut: {
        payload: Prisma.$inclutPayload<ExtArgs>
        fields: Prisma.inclutFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inclutFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inclutPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inclutFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inclutPayload>
          }
          findFirst: {
            args: Prisma.inclutFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inclutPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inclutFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inclutPayload>
          }
          findMany: {
            args: Prisma.inclutFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inclutPayload>[]
          }
          create: {
            args: Prisma.inclutCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inclutPayload>
          }
          createMany: {
            args: Prisma.inclutCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.inclutDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inclutPayload>
          }
          update: {
            args: Prisma.inclutUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inclutPayload>
          }
          deleteMany: {
            args: Prisma.inclutDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.inclutUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.inclutUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inclutPayload>
          }
          aggregate: {
            args: Prisma.InclutAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInclut>
          }
          groupBy: {
            args: Prisma.inclutGroupByArgs<ExtArgs>,
            result: $Utils.Optional<InclutGroupByOutputType>[]
          }
          count: {
            args: Prisma.inclutCountArgs<ExtArgs>,
            result: $Utils.Optional<InclutCountAggregateOutputType> | number
          }
        }
      }
      methodedepaiement: {
        payload: Prisma.$methodedepaiementPayload<ExtArgs>
        fields: Prisma.methodedepaiementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.methodedepaiementFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$methodedepaiementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.methodedepaiementFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$methodedepaiementPayload>
          }
          findFirst: {
            args: Prisma.methodedepaiementFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$methodedepaiementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.methodedepaiementFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$methodedepaiementPayload>
          }
          findMany: {
            args: Prisma.methodedepaiementFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$methodedepaiementPayload>[]
          }
          create: {
            args: Prisma.methodedepaiementCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$methodedepaiementPayload>
          }
          createMany: {
            args: Prisma.methodedepaiementCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.methodedepaiementDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$methodedepaiementPayload>
          }
          update: {
            args: Prisma.methodedepaiementUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$methodedepaiementPayload>
          }
          deleteMany: {
            args: Prisma.methodedepaiementDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.methodedepaiementUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.methodedepaiementUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$methodedepaiementPayload>
          }
          aggregate: {
            args: Prisma.MethodedepaiementAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMethodedepaiement>
          }
          groupBy: {
            args: Prisma.methodedepaiementGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MethodedepaiementGroupByOutputType>[]
          }
          count: {
            args: Prisma.methodedepaiementCountArgs<ExtArgs>,
            result: $Utils.Optional<MethodedepaiementCountAggregateOutputType> | number
          }
        }
      }
      motos: {
        payload: Prisma.$motosPayload<ExtArgs>
        fields: Prisma.motosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.motosFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$motosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.motosFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$motosPayload>
          }
          findFirst: {
            args: Prisma.motosFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$motosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.motosFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$motosPayload>
          }
          findMany: {
            args: Prisma.motosFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$motosPayload>[]
          }
          create: {
            args: Prisma.motosCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$motosPayload>
          }
          createMany: {
            args: Prisma.motosCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.motosDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$motosPayload>
          }
          update: {
            args: Prisma.motosUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$motosPayload>
          }
          deleteMany: {
            args: Prisma.motosDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.motosUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.motosUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$motosPayload>
          }
          aggregate: {
            args: Prisma.MotosAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMotos>
          }
          groupBy: {
            args: Prisma.motosGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MotosGroupByOutputType>[]
          }
          count: {
            args: Prisma.motosCountArgs<ExtArgs>,
            result: $Utils.Optional<MotosCountAggregateOutputType> | number
          }
        }
      }
      panier: {
        payload: Prisma.$panierPayload<ExtArgs>
        fields: Prisma.panierFieldRefs
        operations: {
          findUnique: {
            args: Prisma.panierFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$panierPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.panierFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$panierPayload>
          }
          findFirst: {
            args: Prisma.panierFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$panierPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.panierFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$panierPayload>
          }
          findMany: {
            args: Prisma.panierFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$panierPayload>[]
          }
          create: {
            args: Prisma.panierCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$panierPayload>
          }
          createMany: {
            args: Prisma.panierCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.panierDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$panierPayload>
          }
          update: {
            args: Prisma.panierUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$panierPayload>
          }
          deleteMany: {
            args: Prisma.panierDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.panierUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.panierUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$panierPayload>
          }
          aggregate: {
            args: Prisma.PanierAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePanier>
          }
          groupBy: {
            args: Prisma.panierGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PanierGroupByOutputType>[]
          }
          count: {
            args: Prisma.panierCountArgs<ExtArgs>,
            result: $Utils.Optional<PanierCountAggregateOutputType> | number
          }
        }
      }
      utilise: {
        payload: Prisma.$utilisePayload<ExtArgs>
        fields: Prisma.utiliseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.utiliseFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$utilisePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.utiliseFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$utilisePayload>
          }
          findFirst: {
            args: Prisma.utiliseFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$utilisePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.utiliseFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$utilisePayload>
          }
          findMany: {
            args: Prisma.utiliseFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$utilisePayload>[]
          }
          create: {
            args: Prisma.utiliseCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$utilisePayload>
          }
          createMany: {
            args: Prisma.utiliseCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.utiliseDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$utilisePayload>
          }
          update: {
            args: Prisma.utiliseUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$utilisePayload>
          }
          deleteMany: {
            args: Prisma.utiliseDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.utiliseUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.utiliseUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$utilisePayload>
          }
          aggregate: {
            args: Prisma.UtiliseAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUtilise>
          }
          groupBy: {
            args: Prisma.utiliseGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UtiliseGroupByOutputType>[]
          }
          count: {
            args: Prisma.utiliseCountArgs<ExtArgs>,
            result: $Utils.Optional<UtiliseCountAggregateOutputType> | number
          }
        }
      }
      motossurcommande: {
        payload: Prisma.$motossurcommandePayload<ExtArgs>
        fields: Prisma.motossurcommandeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.motossurcommandeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$motossurcommandePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.motossurcommandeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$motossurcommandePayload>
          }
          findFirst: {
            args: Prisma.motossurcommandeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$motossurcommandePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.motossurcommandeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$motossurcommandePayload>
          }
          findMany: {
            args: Prisma.motossurcommandeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$motossurcommandePayload>[]
          }
          create: {
            args: Prisma.motossurcommandeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$motossurcommandePayload>
          }
          createMany: {
            args: Prisma.motossurcommandeCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.motossurcommandeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$motossurcommandePayload>
          }
          update: {
            args: Prisma.motossurcommandeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$motossurcommandePayload>
          }
          deleteMany: {
            args: Prisma.motossurcommandeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.motossurcommandeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.motossurcommandeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$motossurcommandePayload>
          }
          aggregate: {
            args: Prisma.MotossurcommandeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMotossurcommande>
          }
          groupBy: {
            args: Prisma.motossurcommandeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MotossurcommandeGroupByOutputType>[]
          }
          count: {
            args: Prisma.motossurcommandeCountArgs<ExtArgs>,
            result: $Utils.Optional<MotossurcommandeCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */



  /**
   * Models
   */

  /**
   * Model adresse
   */

  export type AggregateAdresse = {
    _count: AdresseCountAggregateOutputType | null
    _avg: AdresseAvgAggregateOutputType | null
    _sum: AdresseSumAggregateOutputType | null
    _min: AdresseMinAggregateOutputType | null
    _max: AdresseMaxAggregateOutputType | null
  }

  export type AdresseAvgAggregateOutputType = {
    IdAdresse: number | null
    IdClient: number | null
  }

  export type AdresseSumAggregateOutputType = {
    IdAdresse: number | null
    IdClient: number | null
  }

  export type AdresseMinAggregateOutputType = {
    IdAdresse: number | null
    AdresseDeFacturation: string | null
    AdresseDeLivraison: string | null
    NomDuDestinataire: string | null
    Adresse: string | null
    Ville: string | null
    NumeroDeTelephone: string | null
    CodePostal: string | null
    Pays: string | null
    IdClient: number | null
  }

  export type AdresseMaxAggregateOutputType = {
    IdAdresse: number | null
    AdresseDeFacturation: string | null
    AdresseDeLivraison: string | null
    NomDuDestinataire: string | null
    Adresse: string | null
    Ville: string | null
    NumeroDeTelephone: string | null
    CodePostal: string | null
    Pays: string | null
    IdClient: number | null
  }

  export type AdresseCountAggregateOutputType = {
    IdAdresse: number
    AdresseDeFacturation: number
    AdresseDeLivraison: number
    NomDuDestinataire: number
    Adresse: number
    Ville: number
    NumeroDeTelephone: number
    CodePostal: number
    Pays: number
    IdClient: number
    _all: number
  }


  export type AdresseAvgAggregateInputType = {
    IdAdresse?: true
    IdClient?: true
  }

  export type AdresseSumAggregateInputType = {
    IdAdresse?: true
    IdClient?: true
  }

  export type AdresseMinAggregateInputType = {
    IdAdresse?: true
    AdresseDeFacturation?: true
    AdresseDeLivraison?: true
    NomDuDestinataire?: true
    Adresse?: true
    Ville?: true
    NumeroDeTelephone?: true
    CodePostal?: true
    Pays?: true
    IdClient?: true
  }

  export type AdresseMaxAggregateInputType = {
    IdAdresse?: true
    AdresseDeFacturation?: true
    AdresseDeLivraison?: true
    NomDuDestinataire?: true
    Adresse?: true
    Ville?: true
    NumeroDeTelephone?: true
    CodePostal?: true
    Pays?: true
    IdClient?: true
  }

  export type AdresseCountAggregateInputType = {
    IdAdresse?: true
    AdresseDeFacturation?: true
    AdresseDeLivraison?: true
    NomDuDestinataire?: true
    Adresse?: true
    Ville?: true
    NumeroDeTelephone?: true
    CodePostal?: true
    Pays?: true
    IdClient?: true
    _all?: true
  }

  export type AdresseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which adresse to aggregate.
     */
    where?: adresseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of adresses to fetch.
     */
    orderBy?: adresseOrderByWithRelationInput | adresseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: adresseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` adresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` adresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned adresses
    **/
    _count?: true | AdresseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdresseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdresseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdresseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdresseMaxAggregateInputType
  }

  export type GetAdresseAggregateType<T extends AdresseAggregateArgs> = {
        [P in keyof T & keyof AggregateAdresse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdresse[P]>
      : GetScalarType<T[P], AggregateAdresse[P]>
  }




  export type adresseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: adresseWhereInput
    orderBy?: adresseOrderByWithAggregationInput | adresseOrderByWithAggregationInput[]
    by: AdresseScalarFieldEnum[] | AdresseScalarFieldEnum
    having?: adresseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdresseCountAggregateInputType | true
    _avg?: AdresseAvgAggregateInputType
    _sum?: AdresseSumAggregateInputType
    _min?: AdresseMinAggregateInputType
    _max?: AdresseMaxAggregateInputType
  }

  export type AdresseGroupByOutputType = {
    IdAdresse: number
    AdresseDeFacturation: string
    AdresseDeLivraison: string
    NomDuDestinataire: string
    Adresse: string
    Ville: string
    NumeroDeTelephone: string
    CodePostal: string
    Pays: string
    IdClient: number | null
    _count: AdresseCountAggregateOutputType | null
    _avg: AdresseAvgAggregateOutputType | null
    _sum: AdresseSumAggregateOutputType | null
    _min: AdresseMinAggregateOutputType | null
    _max: AdresseMaxAggregateOutputType | null
  }

  type GetAdresseGroupByPayload<T extends adresseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdresseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdresseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdresseGroupByOutputType[P]>
            : GetScalarType<T[P], AdresseGroupByOutputType[P]>
        }
      >
    >


  export type adresseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdAdresse?: boolean
    AdresseDeFacturation?: boolean
    AdresseDeLivraison?: boolean
    NomDuDestinataire?: boolean
    Adresse?: boolean
    Ville?: boolean
    NumeroDeTelephone?: boolean
    CodePostal?: boolean
    Pays?: boolean
    IdClient?: boolean
  }, ExtArgs["result"]["adresse"]>

  export type adresseSelectScalar = {
    IdAdresse?: boolean
    AdresseDeFacturation?: boolean
    AdresseDeLivraison?: boolean
    NomDuDestinataire?: boolean
    Adresse?: boolean
    Ville?: boolean
    NumeroDeTelephone?: boolean
    CodePostal?: boolean
    Pays?: boolean
    IdClient?: boolean
  }


  export type $adressePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "adresse"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      IdAdresse: number
      AdresseDeFacturation: string
      AdresseDeLivraison: string
      NomDuDestinataire: string
      Adresse: string
      Ville: string
      NumeroDeTelephone: string
      CodePostal: string
      Pays: string
      IdClient: number | null
    }, ExtArgs["result"]["adresse"]>
    composites: {}
  }


  type adresseGetPayload<S extends boolean | null | undefined | adresseDefaultArgs> = $Result.GetResult<Prisma.$adressePayload, S>

  type adresseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<adresseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdresseCountAggregateInputType | true
    }

  export interface adresseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['adresse'], meta: { name: 'adresse' } }
    /**
     * Find zero or one Adresse that matches the filter.
     * @param {adresseFindUniqueArgs} args - Arguments to find a Adresse
     * @example
     * // Get one Adresse
     * const adresse = await prisma.adresse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends adresseFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, adresseFindUniqueArgs<ExtArgs>>
    ): Prisma__adresseClient<$Result.GetResult<Prisma.$adressePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Adresse that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {adresseFindUniqueOrThrowArgs} args - Arguments to find a Adresse
     * @example
     * // Get one Adresse
     * const adresse = await prisma.adresse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends adresseFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, adresseFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__adresseClient<$Result.GetResult<Prisma.$adressePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Adresse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adresseFindFirstArgs} args - Arguments to find a Adresse
     * @example
     * // Get one Adresse
     * const adresse = await prisma.adresse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends adresseFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, adresseFindFirstArgs<ExtArgs>>
    ): Prisma__adresseClient<$Result.GetResult<Prisma.$adressePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Adresse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adresseFindFirstOrThrowArgs} args - Arguments to find a Adresse
     * @example
     * // Get one Adresse
     * const adresse = await prisma.adresse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends adresseFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, adresseFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__adresseClient<$Result.GetResult<Prisma.$adressePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Adresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adresseFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Adresses
     * const adresses = await prisma.adresse.findMany()
     * 
     * // Get first 10 Adresses
     * const adresses = await prisma.adresse.findMany({ take: 10 })
     * 
     * // Only select the `IdAdresse`
     * const adresseWithIdAdresseOnly = await prisma.adresse.findMany({ select: { IdAdresse: true } })
     * 
    **/
    findMany<T extends adresseFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, adresseFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$adressePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Adresse.
     * @param {adresseCreateArgs} args - Arguments to create a Adresse.
     * @example
     * // Create one Adresse
     * const Adresse = await prisma.adresse.create({
     *   data: {
     *     // ... data to create a Adresse
     *   }
     * })
     * 
    **/
    create<T extends adresseCreateArgs<ExtArgs>>(
      args: SelectSubset<T, adresseCreateArgs<ExtArgs>>
    ): Prisma__adresseClient<$Result.GetResult<Prisma.$adressePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Adresses.
     *     @param {adresseCreateManyArgs} args - Arguments to create many Adresses.
     *     @example
     *     // Create many Adresses
     *     const adresse = await prisma.adresse.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends adresseCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, adresseCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Adresse.
     * @param {adresseDeleteArgs} args - Arguments to delete one Adresse.
     * @example
     * // Delete one Adresse
     * const Adresse = await prisma.adresse.delete({
     *   where: {
     *     // ... filter to delete one Adresse
     *   }
     * })
     * 
    **/
    delete<T extends adresseDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, adresseDeleteArgs<ExtArgs>>
    ): Prisma__adresseClient<$Result.GetResult<Prisma.$adressePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Adresse.
     * @param {adresseUpdateArgs} args - Arguments to update one Adresse.
     * @example
     * // Update one Adresse
     * const adresse = await prisma.adresse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends adresseUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, adresseUpdateArgs<ExtArgs>>
    ): Prisma__adresseClient<$Result.GetResult<Prisma.$adressePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Adresses.
     * @param {adresseDeleteManyArgs} args - Arguments to filter Adresses to delete.
     * @example
     * // Delete a few Adresses
     * const { count } = await prisma.adresse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends adresseDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, adresseDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Adresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adresseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Adresses
     * const adresse = await prisma.adresse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends adresseUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, adresseUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Adresse.
     * @param {adresseUpsertArgs} args - Arguments to update or create a Adresse.
     * @example
     * // Update or create a Adresse
     * const adresse = await prisma.adresse.upsert({
     *   create: {
     *     // ... data to create a Adresse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Adresse we want to update
     *   }
     * })
    **/
    upsert<T extends adresseUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, adresseUpsertArgs<ExtArgs>>
    ): Prisma__adresseClient<$Result.GetResult<Prisma.$adressePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Adresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adresseCountArgs} args - Arguments to filter Adresses to count.
     * @example
     * // Count the number of Adresses
     * const count = await prisma.adresse.count({
     *   where: {
     *     // ... the filter for the Adresses we want to count
     *   }
     * })
    **/
    count<T extends adresseCountArgs>(
      args?: Subset<T, adresseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdresseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Adresse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdresseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdresseAggregateArgs>(args: Subset<T, AdresseAggregateArgs>): Prisma.PrismaPromise<GetAdresseAggregateType<T>>

    /**
     * Group by Adresse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adresseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends adresseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: adresseGroupByArgs['orderBy'] }
        : { orderBy?: adresseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, adresseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdresseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the adresse model
   */
  readonly fields: adresseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for adresse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__adresseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the adresse model
   */ 
  interface adresseFieldRefs {
    readonly IdAdresse: FieldRef<"adresse", 'Int'>
    readonly AdresseDeFacturation: FieldRef<"adresse", 'String'>
    readonly AdresseDeLivraison: FieldRef<"adresse", 'String'>
    readonly NomDuDestinataire: FieldRef<"adresse", 'String'>
    readonly Adresse: FieldRef<"adresse", 'String'>
    readonly Ville: FieldRef<"adresse", 'String'>
    readonly NumeroDeTelephone: FieldRef<"adresse", 'String'>
    readonly CodePostal: FieldRef<"adresse", 'String'>
    readonly Pays: FieldRef<"adresse", 'String'>
    readonly IdClient: FieldRef<"adresse", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * adresse findUnique
   */
  export type adresseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the adresse
     */
    select?: adresseSelect<ExtArgs> | null
    /**
     * Filter, which adresse to fetch.
     */
    where: adresseWhereUniqueInput
  }


  /**
   * adresse findUniqueOrThrow
   */
  export type adresseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the adresse
     */
    select?: adresseSelect<ExtArgs> | null
    /**
     * Filter, which adresse to fetch.
     */
    where: adresseWhereUniqueInput
  }


  /**
   * adresse findFirst
   */
  export type adresseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the adresse
     */
    select?: adresseSelect<ExtArgs> | null
    /**
     * Filter, which adresse to fetch.
     */
    where?: adresseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of adresses to fetch.
     */
    orderBy?: adresseOrderByWithRelationInput | adresseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for adresses.
     */
    cursor?: adresseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` adresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` adresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of adresses.
     */
    distinct?: AdresseScalarFieldEnum | AdresseScalarFieldEnum[]
  }


  /**
   * adresse findFirstOrThrow
   */
  export type adresseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the adresse
     */
    select?: adresseSelect<ExtArgs> | null
    /**
     * Filter, which adresse to fetch.
     */
    where?: adresseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of adresses to fetch.
     */
    orderBy?: adresseOrderByWithRelationInput | adresseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for adresses.
     */
    cursor?: adresseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` adresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` adresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of adresses.
     */
    distinct?: AdresseScalarFieldEnum | AdresseScalarFieldEnum[]
  }


  /**
   * adresse findMany
   */
  export type adresseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the adresse
     */
    select?: adresseSelect<ExtArgs> | null
    /**
     * Filter, which adresses to fetch.
     */
    where?: adresseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of adresses to fetch.
     */
    orderBy?: adresseOrderByWithRelationInput | adresseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing adresses.
     */
    cursor?: adresseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` adresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` adresses.
     */
    skip?: number
    distinct?: AdresseScalarFieldEnum | AdresseScalarFieldEnum[]
  }


  /**
   * adresse create
   */
  export type adresseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the adresse
     */
    select?: adresseSelect<ExtArgs> | null
    /**
     * The data needed to create a adresse.
     */
    data: XOR<adresseCreateInput, adresseUncheckedCreateInput>
  }


  /**
   * adresse createMany
   */
  export type adresseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many adresses.
     */
    data: adresseCreateManyInput | adresseCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * adresse update
   */
  export type adresseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the adresse
     */
    select?: adresseSelect<ExtArgs> | null
    /**
     * The data needed to update a adresse.
     */
    data: XOR<adresseUpdateInput, adresseUncheckedUpdateInput>
    /**
     * Choose, which adresse to update.
     */
    where: adresseWhereUniqueInput
  }


  /**
   * adresse updateMany
   */
  export type adresseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update adresses.
     */
    data: XOR<adresseUpdateManyMutationInput, adresseUncheckedUpdateManyInput>
    /**
     * Filter which adresses to update
     */
    where?: adresseWhereInput
  }


  /**
   * adresse upsert
   */
  export type adresseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the adresse
     */
    select?: adresseSelect<ExtArgs> | null
    /**
     * The filter to search for the adresse to update in case it exists.
     */
    where: adresseWhereUniqueInput
    /**
     * In case the adresse found by the `where` argument doesn't exist, create a new adresse with this data.
     */
    create: XOR<adresseCreateInput, adresseUncheckedCreateInput>
    /**
     * In case the adresse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<adresseUpdateInput, adresseUncheckedUpdateInput>
  }


  /**
   * adresse delete
   */
  export type adresseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the adresse
     */
    select?: adresseSelect<ExtArgs> | null
    /**
     * Filter which adresse to delete.
     */
    where: adresseWhereUniqueInput
  }


  /**
   * adresse deleteMany
   */
  export type adresseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which adresses to delete
     */
    where?: adresseWhereInput
  }


  /**
   * adresse without action
   */
  export type adresseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the adresse
     */
    select?: adresseSelect<ExtArgs> | null
  }



  /**
   * Model choisit
   */

  export type AggregateChoisit = {
    _count: ChoisitCountAggregateOutputType | null
    _avg: ChoisitAvgAggregateOutputType | null
    _sum: ChoisitSumAggregateOutputType | null
    _min: ChoisitMinAggregateOutputType | null
    _max: ChoisitMaxAggregateOutputType | null
  }

  export type ChoisitAvgAggregateOutputType = {
    IdClient: number | null
    IdMoto: number | null
  }

  export type ChoisitSumAggregateOutputType = {
    IdClient: number | null
    IdMoto: number | null
  }

  export type ChoisitMinAggregateOutputType = {
    IdClient: number | null
    IdMoto: number | null
  }

  export type ChoisitMaxAggregateOutputType = {
    IdClient: number | null
    IdMoto: number | null
  }

  export type ChoisitCountAggregateOutputType = {
    IdClient: number
    IdMoto: number
    _all: number
  }


  export type ChoisitAvgAggregateInputType = {
    IdClient?: true
    IdMoto?: true
  }

  export type ChoisitSumAggregateInputType = {
    IdClient?: true
    IdMoto?: true
  }

  export type ChoisitMinAggregateInputType = {
    IdClient?: true
    IdMoto?: true
  }

  export type ChoisitMaxAggregateInputType = {
    IdClient?: true
    IdMoto?: true
  }

  export type ChoisitCountAggregateInputType = {
    IdClient?: true
    IdMoto?: true
    _all?: true
  }

  export type ChoisitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which choisit to aggregate.
     */
    where?: choisitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of choisits to fetch.
     */
    orderBy?: choisitOrderByWithRelationInput | choisitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: choisitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` choisits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` choisits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned choisits
    **/
    _count?: true | ChoisitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChoisitAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChoisitSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChoisitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChoisitMaxAggregateInputType
  }

  export type GetChoisitAggregateType<T extends ChoisitAggregateArgs> = {
        [P in keyof T & keyof AggregateChoisit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChoisit[P]>
      : GetScalarType<T[P], AggregateChoisit[P]>
  }




  export type choisitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: choisitWhereInput
    orderBy?: choisitOrderByWithAggregationInput | choisitOrderByWithAggregationInput[]
    by: ChoisitScalarFieldEnum[] | ChoisitScalarFieldEnum
    having?: choisitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChoisitCountAggregateInputType | true
    _avg?: ChoisitAvgAggregateInputType
    _sum?: ChoisitSumAggregateInputType
    _min?: ChoisitMinAggregateInputType
    _max?: ChoisitMaxAggregateInputType
  }

  export type ChoisitGroupByOutputType = {
    IdClient: number
    IdMoto: number
    _count: ChoisitCountAggregateOutputType | null
    _avg: ChoisitAvgAggregateOutputType | null
    _sum: ChoisitSumAggregateOutputType | null
    _min: ChoisitMinAggregateOutputType | null
    _max: ChoisitMaxAggregateOutputType | null
  }

  type GetChoisitGroupByPayload<T extends choisitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChoisitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChoisitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChoisitGroupByOutputType[P]>
            : GetScalarType<T[P], ChoisitGroupByOutputType[P]>
        }
      >
    >


  export type choisitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdClient?: boolean
    IdMoto?: boolean
  }, ExtArgs["result"]["choisit"]>

  export type choisitSelectScalar = {
    IdClient?: boolean
    IdMoto?: boolean
  }


  export type $choisitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "choisit"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      IdClient: number
      IdMoto: number
    }, ExtArgs["result"]["choisit"]>
    composites: {}
  }


  type choisitGetPayload<S extends boolean | null | undefined | choisitDefaultArgs> = $Result.GetResult<Prisma.$choisitPayload, S>

  type choisitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<choisitFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ChoisitCountAggregateInputType | true
    }

  export interface choisitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['choisit'], meta: { name: 'choisit' } }
    /**
     * Find zero or one Choisit that matches the filter.
     * @param {choisitFindUniqueArgs} args - Arguments to find a Choisit
     * @example
     * // Get one Choisit
     * const choisit = await prisma.choisit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends choisitFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, choisitFindUniqueArgs<ExtArgs>>
    ): Prisma__choisitClient<$Result.GetResult<Prisma.$choisitPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Choisit that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {choisitFindUniqueOrThrowArgs} args - Arguments to find a Choisit
     * @example
     * // Get one Choisit
     * const choisit = await prisma.choisit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends choisitFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, choisitFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__choisitClient<$Result.GetResult<Prisma.$choisitPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Choisit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {choisitFindFirstArgs} args - Arguments to find a Choisit
     * @example
     * // Get one Choisit
     * const choisit = await prisma.choisit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends choisitFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, choisitFindFirstArgs<ExtArgs>>
    ): Prisma__choisitClient<$Result.GetResult<Prisma.$choisitPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Choisit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {choisitFindFirstOrThrowArgs} args - Arguments to find a Choisit
     * @example
     * // Get one Choisit
     * const choisit = await prisma.choisit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends choisitFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, choisitFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__choisitClient<$Result.GetResult<Prisma.$choisitPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Choisits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {choisitFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Choisits
     * const choisits = await prisma.choisit.findMany()
     * 
     * // Get first 10 Choisits
     * const choisits = await prisma.choisit.findMany({ take: 10 })
     * 
     * // Only select the `IdClient`
     * const choisitWithIdClientOnly = await prisma.choisit.findMany({ select: { IdClient: true } })
     * 
    **/
    findMany<T extends choisitFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, choisitFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$choisitPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Choisit.
     * @param {choisitCreateArgs} args - Arguments to create a Choisit.
     * @example
     * // Create one Choisit
     * const Choisit = await prisma.choisit.create({
     *   data: {
     *     // ... data to create a Choisit
     *   }
     * })
     * 
    **/
    create<T extends choisitCreateArgs<ExtArgs>>(
      args: SelectSubset<T, choisitCreateArgs<ExtArgs>>
    ): Prisma__choisitClient<$Result.GetResult<Prisma.$choisitPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Choisits.
     *     @param {choisitCreateManyArgs} args - Arguments to create many Choisits.
     *     @example
     *     // Create many Choisits
     *     const choisit = await prisma.choisit.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends choisitCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, choisitCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Choisit.
     * @param {choisitDeleteArgs} args - Arguments to delete one Choisit.
     * @example
     * // Delete one Choisit
     * const Choisit = await prisma.choisit.delete({
     *   where: {
     *     // ... filter to delete one Choisit
     *   }
     * })
     * 
    **/
    delete<T extends choisitDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, choisitDeleteArgs<ExtArgs>>
    ): Prisma__choisitClient<$Result.GetResult<Prisma.$choisitPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Choisit.
     * @param {choisitUpdateArgs} args - Arguments to update one Choisit.
     * @example
     * // Update one Choisit
     * const choisit = await prisma.choisit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends choisitUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, choisitUpdateArgs<ExtArgs>>
    ): Prisma__choisitClient<$Result.GetResult<Prisma.$choisitPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Choisits.
     * @param {choisitDeleteManyArgs} args - Arguments to filter Choisits to delete.
     * @example
     * // Delete a few Choisits
     * const { count } = await prisma.choisit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends choisitDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, choisitDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Choisits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {choisitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Choisits
     * const choisit = await prisma.choisit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends choisitUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, choisitUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Choisit.
     * @param {choisitUpsertArgs} args - Arguments to update or create a Choisit.
     * @example
     * // Update or create a Choisit
     * const choisit = await prisma.choisit.upsert({
     *   create: {
     *     // ... data to create a Choisit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Choisit we want to update
     *   }
     * })
    **/
    upsert<T extends choisitUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, choisitUpsertArgs<ExtArgs>>
    ): Prisma__choisitClient<$Result.GetResult<Prisma.$choisitPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Choisits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {choisitCountArgs} args - Arguments to filter Choisits to count.
     * @example
     * // Count the number of Choisits
     * const count = await prisma.choisit.count({
     *   where: {
     *     // ... the filter for the Choisits we want to count
     *   }
     * })
    **/
    count<T extends choisitCountArgs>(
      args?: Subset<T, choisitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChoisitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Choisit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoisitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChoisitAggregateArgs>(args: Subset<T, ChoisitAggregateArgs>): Prisma.PrismaPromise<GetChoisitAggregateType<T>>

    /**
     * Group by Choisit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {choisitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends choisitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: choisitGroupByArgs['orderBy'] }
        : { orderBy?: choisitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, choisitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChoisitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the choisit model
   */
  readonly fields: choisitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for choisit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__choisitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the choisit model
   */ 
  interface choisitFieldRefs {
    readonly IdClient: FieldRef<"choisit", 'Int'>
    readonly IdMoto: FieldRef<"choisit", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * choisit findUnique
   */
  export type choisitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the choisit
     */
    select?: choisitSelect<ExtArgs> | null
    /**
     * Filter, which choisit to fetch.
     */
    where: choisitWhereUniqueInput
  }


  /**
   * choisit findUniqueOrThrow
   */
  export type choisitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the choisit
     */
    select?: choisitSelect<ExtArgs> | null
    /**
     * Filter, which choisit to fetch.
     */
    where: choisitWhereUniqueInput
  }


  /**
   * choisit findFirst
   */
  export type choisitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the choisit
     */
    select?: choisitSelect<ExtArgs> | null
    /**
     * Filter, which choisit to fetch.
     */
    where?: choisitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of choisits to fetch.
     */
    orderBy?: choisitOrderByWithRelationInput | choisitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for choisits.
     */
    cursor?: choisitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` choisits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` choisits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of choisits.
     */
    distinct?: ChoisitScalarFieldEnum | ChoisitScalarFieldEnum[]
  }


  /**
   * choisit findFirstOrThrow
   */
  export type choisitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the choisit
     */
    select?: choisitSelect<ExtArgs> | null
    /**
     * Filter, which choisit to fetch.
     */
    where?: choisitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of choisits to fetch.
     */
    orderBy?: choisitOrderByWithRelationInput | choisitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for choisits.
     */
    cursor?: choisitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` choisits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` choisits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of choisits.
     */
    distinct?: ChoisitScalarFieldEnum | ChoisitScalarFieldEnum[]
  }


  /**
   * choisit findMany
   */
  export type choisitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the choisit
     */
    select?: choisitSelect<ExtArgs> | null
    /**
     * Filter, which choisits to fetch.
     */
    where?: choisitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of choisits to fetch.
     */
    orderBy?: choisitOrderByWithRelationInput | choisitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing choisits.
     */
    cursor?: choisitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` choisits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` choisits.
     */
    skip?: number
    distinct?: ChoisitScalarFieldEnum | ChoisitScalarFieldEnum[]
  }


  /**
   * choisit create
   */
  export type choisitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the choisit
     */
    select?: choisitSelect<ExtArgs> | null
    /**
     * The data needed to create a choisit.
     */
    data: XOR<choisitCreateInput, choisitUncheckedCreateInput>
  }


  /**
   * choisit createMany
   */
  export type choisitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many choisits.
     */
    data: choisitCreateManyInput | choisitCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * choisit update
   */
  export type choisitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the choisit
     */
    select?: choisitSelect<ExtArgs> | null
    /**
     * The data needed to update a choisit.
     */
    data: XOR<choisitUpdateInput, choisitUncheckedUpdateInput>
    /**
     * Choose, which choisit to update.
     */
    where: choisitWhereUniqueInput
  }


  /**
   * choisit updateMany
   */
  export type choisitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update choisits.
     */
    data: XOR<choisitUpdateManyMutationInput, choisitUncheckedUpdateManyInput>
    /**
     * Filter which choisits to update
     */
    where?: choisitWhereInput
  }


  /**
   * choisit upsert
   */
  export type choisitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the choisit
     */
    select?: choisitSelect<ExtArgs> | null
    /**
     * The filter to search for the choisit to update in case it exists.
     */
    where: choisitWhereUniqueInput
    /**
     * In case the choisit found by the `where` argument doesn't exist, create a new choisit with this data.
     */
    create: XOR<choisitCreateInput, choisitUncheckedCreateInput>
    /**
     * In case the choisit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<choisitUpdateInput, choisitUncheckedUpdateInput>
  }


  /**
   * choisit delete
   */
  export type choisitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the choisit
     */
    select?: choisitSelect<ExtArgs> | null
    /**
     * Filter which choisit to delete.
     */
    where: choisitWhereUniqueInput
  }


  /**
   * choisit deleteMany
   */
  export type choisitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which choisits to delete
     */
    where?: choisitWhereInput
  }


  /**
   * choisit without action
   */
  export type choisitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the choisit
     */
    select?: choisitSelect<ExtArgs> | null
  }



  /**
   * Model client
   */

  export type AggregateClient = {
    _count: ClientCountAggregateOutputType | null
    _avg: ClientAvgAggregateOutputType | null
    _sum: ClientSumAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  export type ClientAvgAggregateOutputType = {
    IdClient: number | null
  }

  export type ClientSumAggregateOutputType = {
    IdClient: number | null
  }

  export type ClientMinAggregateOutputType = {
    IdClient: number | null
    Nom: string | null
    Prenom: string | null
    AddresseMail: string | null
    MotDePasse: string | null
    DateDeNaissance: string | null
    NumeroDeTelephone: string | null
    Anciennete: string | null
  }

  export type ClientMaxAggregateOutputType = {
    IdClient: number | null
    Nom: string | null
    Prenom: string | null
    AddresseMail: string | null
    MotDePasse: string | null
    DateDeNaissance: string | null
    NumeroDeTelephone: string | null
    Anciennete: string | null
  }

  export type ClientCountAggregateOutputType = {
    IdClient: number
    Nom: number
    Prenom: number
    AddresseMail: number
    MotDePasse: number
    DateDeNaissance: number
    NumeroDeTelephone: number
    Anciennete: number
    _all: number
  }


  export type ClientAvgAggregateInputType = {
    IdClient?: true
  }

  export type ClientSumAggregateInputType = {
    IdClient?: true
  }

  export type ClientMinAggregateInputType = {
    IdClient?: true
    Nom?: true
    Prenom?: true
    AddresseMail?: true
    MotDePasse?: true
    DateDeNaissance?: true
    NumeroDeTelephone?: true
    Anciennete?: true
  }

  export type ClientMaxAggregateInputType = {
    IdClient?: true
    Nom?: true
    Prenom?: true
    AddresseMail?: true
    MotDePasse?: true
    DateDeNaissance?: true
    NumeroDeTelephone?: true
    Anciennete?: true
  }

  export type ClientCountAggregateInputType = {
    IdClient?: true
    Nom?: true
    Prenom?: true
    AddresseMail?: true
    MotDePasse?: true
    DateDeNaissance?: true
    NumeroDeTelephone?: true
    Anciennete?: true
    _all?: true
  }

  export type ClientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which client to aggregate.
     */
    where?: clientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clients to fetch.
     */
    orderBy?: clientOrderByWithRelationInput | clientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: clientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned clients
    **/
    _count?: true | ClientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClientAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClientSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientMaxAggregateInputType
  }

  export type GetClientAggregateType<T extends ClientAggregateArgs> = {
        [P in keyof T & keyof AggregateClient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClient[P]>
      : GetScalarType<T[P], AggregateClient[P]>
  }




  export type clientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: clientWhereInput
    orderBy?: clientOrderByWithAggregationInput | clientOrderByWithAggregationInput[]
    by: ClientScalarFieldEnum[] | ClientScalarFieldEnum
    having?: clientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientCountAggregateInputType | true
    _avg?: ClientAvgAggregateInputType
    _sum?: ClientSumAggregateInputType
    _min?: ClientMinAggregateInputType
    _max?: ClientMaxAggregateInputType
  }

  export type ClientGroupByOutputType = {
    IdClient: number
    Nom: string
    Prenom: string
    AddresseMail: string
    MotDePasse: string
    DateDeNaissance: string | null
    NumeroDeTelephone: string
    Anciennete: string | null
    _count: ClientCountAggregateOutputType | null
    _avg: ClientAvgAggregateOutputType | null
    _sum: ClientSumAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  type GetClientGroupByPayload<T extends clientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientGroupByOutputType[P]>
            : GetScalarType<T[P], ClientGroupByOutputType[P]>
        }
      >
    >


  export type clientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdClient?: boolean
    Nom?: boolean
    Prenom?: boolean
    AddresseMail?: boolean
    MotDePasse?: boolean
    DateDeNaissance?: boolean
    NumeroDeTelephone?: boolean
    Anciennete?: boolean
  }, ExtArgs["result"]["client"]>

  export type clientSelectScalar = {
    IdClient?: boolean
    Nom?: boolean
    Prenom?: boolean
    AddresseMail?: boolean
    MotDePasse?: boolean
    DateDeNaissance?: boolean
    NumeroDeTelephone?: boolean
    Anciennete?: boolean
  }


  export type $clientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "client"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      IdClient: number
      Nom: string
      Prenom: string
      AddresseMail: string
      MotDePasse: string
      DateDeNaissance: string | null
      NumeroDeTelephone: string
      Anciennete: string | null
    }, ExtArgs["result"]["client"]>
    composites: {}
  }


  type clientGetPayload<S extends boolean | null | undefined | clientDefaultArgs> = $Result.GetResult<Prisma.$clientPayload, S>

  type clientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<clientFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClientCountAggregateInputType | true
    }

  export interface clientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['client'], meta: { name: 'client' } }
    /**
     * Find zero or one Client that matches the filter.
     * @param {clientFindUniqueArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends clientFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, clientFindUniqueArgs<ExtArgs>>
    ): Prisma__clientClient<$Result.GetResult<Prisma.$clientPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Client that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {clientFindUniqueOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends clientFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, clientFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__clientClient<$Result.GetResult<Prisma.$clientPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Client that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientFindFirstArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends clientFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, clientFindFirstArgs<ExtArgs>>
    ): Prisma__clientClient<$Result.GetResult<Prisma.$clientPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Client that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientFindFirstOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends clientFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, clientFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__clientClient<$Result.GetResult<Prisma.$clientPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Clients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clients
     * const clients = await prisma.client.findMany()
     * 
     * // Get first 10 Clients
     * const clients = await prisma.client.findMany({ take: 10 })
     * 
     * // Only select the `IdClient`
     * const clientWithIdClientOnly = await prisma.client.findMany({ select: { IdClient: true } })
     * 
    **/
    findMany<T extends clientFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, clientFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$clientPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Client.
     * @param {clientCreateArgs} args - Arguments to create a Client.
     * @example
     * // Create one Client
     * const Client = await prisma.client.create({
     *   data: {
     *     // ... data to create a Client
     *   }
     * })
     * 
    **/
    create<T extends clientCreateArgs<ExtArgs>>(
      args: SelectSubset<T, clientCreateArgs<ExtArgs>>
    ): Prisma__clientClient<$Result.GetResult<Prisma.$clientPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Clients.
     *     @param {clientCreateManyArgs} args - Arguments to create many Clients.
     *     @example
     *     // Create many Clients
     *     const client = await prisma.client.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends clientCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, clientCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Client.
     * @param {clientDeleteArgs} args - Arguments to delete one Client.
     * @example
     * // Delete one Client
     * const Client = await prisma.client.delete({
     *   where: {
     *     // ... filter to delete one Client
     *   }
     * })
     * 
    **/
    delete<T extends clientDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, clientDeleteArgs<ExtArgs>>
    ): Prisma__clientClient<$Result.GetResult<Prisma.$clientPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Client.
     * @param {clientUpdateArgs} args - Arguments to update one Client.
     * @example
     * // Update one Client
     * const client = await prisma.client.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends clientUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, clientUpdateArgs<ExtArgs>>
    ): Prisma__clientClient<$Result.GetResult<Prisma.$clientPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Clients.
     * @param {clientDeleteManyArgs} args - Arguments to filter Clients to delete.
     * @example
     * // Delete a few Clients
     * const { count } = await prisma.client.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends clientDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, clientDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clients
     * const client = await prisma.client.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends clientUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, clientUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Client.
     * @param {clientUpsertArgs} args - Arguments to update or create a Client.
     * @example
     * // Update or create a Client
     * const client = await prisma.client.upsert({
     *   create: {
     *     // ... data to create a Client
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Client we want to update
     *   }
     * })
    **/
    upsert<T extends clientUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, clientUpsertArgs<ExtArgs>>
    ): Prisma__clientClient<$Result.GetResult<Prisma.$clientPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientCountArgs} args - Arguments to filter Clients to count.
     * @example
     * // Count the number of Clients
     * const count = await prisma.client.count({
     *   where: {
     *     // ... the filter for the Clients we want to count
     *   }
     * })
    **/
    count<T extends clientCountArgs>(
      args?: Subset<T, clientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientAggregateArgs>(args: Subset<T, ClientAggregateArgs>): Prisma.PrismaPromise<GetClientAggregateType<T>>

    /**
     * Group by Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends clientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: clientGroupByArgs['orderBy'] }
        : { orderBy?: clientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, clientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the client model
   */
  readonly fields: clientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for client.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__clientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the client model
   */ 
  interface clientFieldRefs {
    readonly IdClient: FieldRef<"client", 'Int'>
    readonly Nom: FieldRef<"client", 'String'>
    readonly Prenom: FieldRef<"client", 'String'>
    readonly AddresseMail: FieldRef<"client", 'String'>
    readonly MotDePasse: FieldRef<"client", 'String'>
    readonly DateDeNaissance: FieldRef<"client", 'String'>
    readonly NumeroDeTelephone: FieldRef<"client", 'String'>
    readonly Anciennete: FieldRef<"client", 'String'>
  }
    

  // Custom InputTypes

  /**
   * client findUnique
   */
  export type clientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client
     */
    select?: clientSelect<ExtArgs> | null
    /**
     * Filter, which client to fetch.
     */
    where: clientWhereUniqueInput
  }


  /**
   * client findUniqueOrThrow
   */
  export type clientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client
     */
    select?: clientSelect<ExtArgs> | null
    /**
     * Filter, which client to fetch.
     */
    where: clientWhereUniqueInput
  }


  /**
   * client findFirst
   */
  export type clientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client
     */
    select?: clientSelect<ExtArgs> | null
    /**
     * Filter, which client to fetch.
     */
    where?: clientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clients to fetch.
     */
    orderBy?: clientOrderByWithRelationInput | clientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for clients.
     */
    cursor?: clientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }


  /**
   * client findFirstOrThrow
   */
  export type clientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client
     */
    select?: clientSelect<ExtArgs> | null
    /**
     * Filter, which client to fetch.
     */
    where?: clientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clients to fetch.
     */
    orderBy?: clientOrderByWithRelationInput | clientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for clients.
     */
    cursor?: clientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }


  /**
   * client findMany
   */
  export type clientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client
     */
    select?: clientSelect<ExtArgs> | null
    /**
     * Filter, which clients to fetch.
     */
    where?: clientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clients to fetch.
     */
    orderBy?: clientOrderByWithRelationInput | clientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing clients.
     */
    cursor?: clientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clients.
     */
    skip?: number
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }


  /**
   * client create
   */
  export type clientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client
     */
    select?: clientSelect<ExtArgs> | null
    /**
     * The data needed to create a client.
     */
    data: XOR<clientCreateInput, clientUncheckedCreateInput>
  }


  /**
   * client createMany
   */
  export type clientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many clients.
     */
    data: clientCreateManyInput | clientCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * client update
   */
  export type clientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client
     */
    select?: clientSelect<ExtArgs> | null
    /**
     * The data needed to update a client.
     */
    data: XOR<clientUpdateInput, clientUncheckedUpdateInput>
    /**
     * Choose, which client to update.
     */
    where: clientWhereUniqueInput
  }


  /**
   * client updateMany
   */
  export type clientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update clients.
     */
    data: XOR<clientUpdateManyMutationInput, clientUncheckedUpdateManyInput>
    /**
     * Filter which clients to update
     */
    where?: clientWhereInput
  }


  /**
   * client upsert
   */
  export type clientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client
     */
    select?: clientSelect<ExtArgs> | null
    /**
     * The filter to search for the client to update in case it exists.
     */
    where: clientWhereUniqueInput
    /**
     * In case the client found by the `where` argument doesn't exist, create a new client with this data.
     */
    create: XOR<clientCreateInput, clientUncheckedCreateInput>
    /**
     * In case the client was found with the provided `where` argument, update it with this data.
     */
    update: XOR<clientUpdateInput, clientUncheckedUpdateInput>
  }


  /**
   * client delete
   */
  export type clientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client
     */
    select?: clientSelect<ExtArgs> | null
    /**
     * Filter which client to delete.
     */
    where: clientWhereUniqueInput
  }


  /**
   * client deleteMany
   */
  export type clientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which clients to delete
     */
    where?: clientWhereInput
  }


  /**
   * client without action
   */
  export type clientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client
     */
    select?: clientSelect<ExtArgs> | null
  }



  /**
   * Model commande
   */

  export type AggregateCommande = {
    _count: CommandeCountAggregateOutputType | null
    _avg: CommandeAvgAggregateOutputType | null
    _sum: CommandeSumAggregateOutputType | null
    _min: CommandeMinAggregateOutputType | null
    _max: CommandeMaxAggregateOutputType | null
  }

  export type CommandeAvgAggregateOutputType = {
    IdCommandes: number | null
    IdAdresse: number | null
    IdClient: number | null
  }

  export type CommandeSumAggregateOutputType = {
    IdCommandes: number | null
    IdAdresse: number | null
    IdClient: number | null
  }

  export type CommandeMinAggregateOutputType = {
    IdCommandes: number | null
    DatedeCommande: Date | null
    StatusDeLaCommande: string | null
    IdAdresse: number | null
    IdClient: number | null
  }

  export type CommandeMaxAggregateOutputType = {
    IdCommandes: number | null
    DatedeCommande: Date | null
    StatusDeLaCommande: string | null
    IdAdresse: number | null
    IdClient: number | null
  }

  export type CommandeCountAggregateOutputType = {
    IdCommandes: number
    DatedeCommande: number
    StatusDeLaCommande: number
    IdAdresse: number
    IdClient: number
    _all: number
  }


  export type CommandeAvgAggregateInputType = {
    IdCommandes?: true
    IdAdresse?: true
    IdClient?: true
  }

  export type CommandeSumAggregateInputType = {
    IdCommandes?: true
    IdAdresse?: true
    IdClient?: true
  }

  export type CommandeMinAggregateInputType = {
    IdCommandes?: true
    DatedeCommande?: true
    StatusDeLaCommande?: true
    IdAdresse?: true
    IdClient?: true
  }

  export type CommandeMaxAggregateInputType = {
    IdCommandes?: true
    DatedeCommande?: true
    StatusDeLaCommande?: true
    IdAdresse?: true
    IdClient?: true
  }

  export type CommandeCountAggregateInputType = {
    IdCommandes?: true
    DatedeCommande?: true
    StatusDeLaCommande?: true
    IdAdresse?: true
    IdClient?: true
    _all?: true
  }

  export type CommandeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which commande to aggregate.
     */
    where?: commandeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of commandes to fetch.
     */
    orderBy?: commandeOrderByWithRelationInput | commandeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: commandeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` commandes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` commandes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned commandes
    **/
    _count?: true | CommandeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommandeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommandeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommandeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommandeMaxAggregateInputType
  }

  export type GetCommandeAggregateType<T extends CommandeAggregateArgs> = {
        [P in keyof T & keyof AggregateCommande]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommande[P]>
      : GetScalarType<T[P], AggregateCommande[P]>
  }




  export type commandeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: commandeWhereInput
    orderBy?: commandeOrderByWithAggregationInput | commandeOrderByWithAggregationInput[]
    by: CommandeScalarFieldEnum[] | CommandeScalarFieldEnum
    having?: commandeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommandeCountAggregateInputType | true
    _avg?: CommandeAvgAggregateInputType
    _sum?: CommandeSumAggregateInputType
    _min?: CommandeMinAggregateInputType
    _max?: CommandeMaxAggregateInputType
  }

  export type CommandeGroupByOutputType = {
    IdCommandes: number
    DatedeCommande: Date
    StatusDeLaCommande: string
    IdAdresse: number
    IdClient: number
    _count: CommandeCountAggregateOutputType | null
    _avg: CommandeAvgAggregateOutputType | null
    _sum: CommandeSumAggregateOutputType | null
    _min: CommandeMinAggregateOutputType | null
    _max: CommandeMaxAggregateOutputType | null
  }

  type GetCommandeGroupByPayload<T extends commandeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommandeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommandeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommandeGroupByOutputType[P]>
            : GetScalarType<T[P], CommandeGroupByOutputType[P]>
        }
      >
    >


  export type commandeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdCommandes?: boolean
    DatedeCommande?: boolean
    StatusDeLaCommande?: boolean
    IdAdresse?: boolean
    IdClient?: boolean
  }, ExtArgs["result"]["commande"]>

  export type commandeSelectScalar = {
    IdCommandes?: boolean
    DatedeCommande?: boolean
    StatusDeLaCommande?: boolean
    IdAdresse?: boolean
    IdClient?: boolean
  }


  export type $commandePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "commande"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      IdCommandes: number
      DatedeCommande: Date
      StatusDeLaCommande: string
      IdAdresse: number
      IdClient: number
    }, ExtArgs["result"]["commande"]>
    composites: {}
  }


  type commandeGetPayload<S extends boolean | null | undefined | commandeDefaultArgs> = $Result.GetResult<Prisma.$commandePayload, S>

  type commandeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<commandeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CommandeCountAggregateInputType | true
    }

  export interface commandeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['commande'], meta: { name: 'commande' } }
    /**
     * Find zero or one Commande that matches the filter.
     * @param {commandeFindUniqueArgs} args - Arguments to find a Commande
     * @example
     * // Get one Commande
     * const commande = await prisma.commande.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends commandeFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, commandeFindUniqueArgs<ExtArgs>>
    ): Prisma__commandeClient<$Result.GetResult<Prisma.$commandePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Commande that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {commandeFindUniqueOrThrowArgs} args - Arguments to find a Commande
     * @example
     * // Get one Commande
     * const commande = await prisma.commande.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends commandeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, commandeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__commandeClient<$Result.GetResult<Prisma.$commandePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Commande that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commandeFindFirstArgs} args - Arguments to find a Commande
     * @example
     * // Get one Commande
     * const commande = await prisma.commande.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends commandeFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, commandeFindFirstArgs<ExtArgs>>
    ): Prisma__commandeClient<$Result.GetResult<Prisma.$commandePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Commande that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commandeFindFirstOrThrowArgs} args - Arguments to find a Commande
     * @example
     * // Get one Commande
     * const commande = await prisma.commande.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends commandeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, commandeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__commandeClient<$Result.GetResult<Prisma.$commandePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Commandes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commandeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Commandes
     * const commandes = await prisma.commande.findMany()
     * 
     * // Get first 10 Commandes
     * const commandes = await prisma.commande.findMany({ take: 10 })
     * 
     * // Only select the `IdCommandes`
     * const commandeWithIdCommandesOnly = await prisma.commande.findMany({ select: { IdCommandes: true } })
     * 
    **/
    findMany<T extends commandeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, commandeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$commandePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Commande.
     * @param {commandeCreateArgs} args - Arguments to create a Commande.
     * @example
     * // Create one Commande
     * const Commande = await prisma.commande.create({
     *   data: {
     *     // ... data to create a Commande
     *   }
     * })
     * 
    **/
    create<T extends commandeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, commandeCreateArgs<ExtArgs>>
    ): Prisma__commandeClient<$Result.GetResult<Prisma.$commandePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Commandes.
     *     @param {commandeCreateManyArgs} args - Arguments to create many Commandes.
     *     @example
     *     // Create many Commandes
     *     const commande = await prisma.commande.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends commandeCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, commandeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Commande.
     * @param {commandeDeleteArgs} args - Arguments to delete one Commande.
     * @example
     * // Delete one Commande
     * const Commande = await prisma.commande.delete({
     *   where: {
     *     // ... filter to delete one Commande
     *   }
     * })
     * 
    **/
    delete<T extends commandeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, commandeDeleteArgs<ExtArgs>>
    ): Prisma__commandeClient<$Result.GetResult<Prisma.$commandePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Commande.
     * @param {commandeUpdateArgs} args - Arguments to update one Commande.
     * @example
     * // Update one Commande
     * const commande = await prisma.commande.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends commandeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, commandeUpdateArgs<ExtArgs>>
    ): Prisma__commandeClient<$Result.GetResult<Prisma.$commandePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Commandes.
     * @param {commandeDeleteManyArgs} args - Arguments to filter Commandes to delete.
     * @example
     * // Delete a few Commandes
     * const { count } = await prisma.commande.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends commandeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, commandeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Commandes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commandeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Commandes
     * const commande = await prisma.commande.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends commandeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, commandeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Commande.
     * @param {commandeUpsertArgs} args - Arguments to update or create a Commande.
     * @example
     * // Update or create a Commande
     * const commande = await prisma.commande.upsert({
     *   create: {
     *     // ... data to create a Commande
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Commande we want to update
     *   }
     * })
    **/
    upsert<T extends commandeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, commandeUpsertArgs<ExtArgs>>
    ): Prisma__commandeClient<$Result.GetResult<Prisma.$commandePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Commandes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commandeCountArgs} args - Arguments to filter Commandes to count.
     * @example
     * // Count the number of Commandes
     * const count = await prisma.commande.count({
     *   where: {
     *     // ... the filter for the Commandes we want to count
     *   }
     * })
    **/
    count<T extends commandeCountArgs>(
      args?: Subset<T, commandeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommandeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Commande.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommandeAggregateArgs>(args: Subset<T, CommandeAggregateArgs>): Prisma.PrismaPromise<GetCommandeAggregateType<T>>

    /**
     * Group by Commande.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commandeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends commandeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: commandeGroupByArgs['orderBy'] }
        : { orderBy?: commandeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, commandeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommandeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the commande model
   */
  readonly fields: commandeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for commande.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__commandeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the commande model
   */ 
  interface commandeFieldRefs {
    readonly IdCommandes: FieldRef<"commande", 'Int'>
    readonly DatedeCommande: FieldRef<"commande", 'DateTime'>
    readonly StatusDeLaCommande: FieldRef<"commande", 'String'>
    readonly IdAdresse: FieldRef<"commande", 'Int'>
    readonly IdClient: FieldRef<"commande", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * commande findUnique
   */
  export type commandeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the commande
     */
    select?: commandeSelect<ExtArgs> | null
    /**
     * Filter, which commande to fetch.
     */
    where: commandeWhereUniqueInput
  }


  /**
   * commande findUniqueOrThrow
   */
  export type commandeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the commande
     */
    select?: commandeSelect<ExtArgs> | null
    /**
     * Filter, which commande to fetch.
     */
    where: commandeWhereUniqueInput
  }


  /**
   * commande findFirst
   */
  export type commandeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the commande
     */
    select?: commandeSelect<ExtArgs> | null
    /**
     * Filter, which commande to fetch.
     */
    where?: commandeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of commandes to fetch.
     */
    orderBy?: commandeOrderByWithRelationInput | commandeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for commandes.
     */
    cursor?: commandeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` commandes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` commandes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of commandes.
     */
    distinct?: CommandeScalarFieldEnum | CommandeScalarFieldEnum[]
  }


  /**
   * commande findFirstOrThrow
   */
  export type commandeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the commande
     */
    select?: commandeSelect<ExtArgs> | null
    /**
     * Filter, which commande to fetch.
     */
    where?: commandeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of commandes to fetch.
     */
    orderBy?: commandeOrderByWithRelationInput | commandeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for commandes.
     */
    cursor?: commandeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` commandes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` commandes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of commandes.
     */
    distinct?: CommandeScalarFieldEnum | CommandeScalarFieldEnum[]
  }


  /**
   * commande findMany
   */
  export type commandeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the commande
     */
    select?: commandeSelect<ExtArgs> | null
    /**
     * Filter, which commandes to fetch.
     */
    where?: commandeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of commandes to fetch.
     */
    orderBy?: commandeOrderByWithRelationInput | commandeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing commandes.
     */
    cursor?: commandeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` commandes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` commandes.
     */
    skip?: number
    distinct?: CommandeScalarFieldEnum | CommandeScalarFieldEnum[]
  }


  /**
   * commande create
   */
  export type commandeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the commande
     */
    select?: commandeSelect<ExtArgs> | null
    /**
     * The data needed to create a commande.
     */
    data: XOR<commandeCreateInput, commandeUncheckedCreateInput>
  }


  /**
   * commande createMany
   */
  export type commandeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many commandes.
     */
    data: commandeCreateManyInput | commandeCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * commande update
   */
  export type commandeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the commande
     */
    select?: commandeSelect<ExtArgs> | null
    /**
     * The data needed to update a commande.
     */
    data: XOR<commandeUpdateInput, commandeUncheckedUpdateInput>
    /**
     * Choose, which commande to update.
     */
    where: commandeWhereUniqueInput
  }


  /**
   * commande updateMany
   */
  export type commandeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update commandes.
     */
    data: XOR<commandeUpdateManyMutationInput, commandeUncheckedUpdateManyInput>
    /**
     * Filter which commandes to update
     */
    where?: commandeWhereInput
  }


  /**
   * commande upsert
   */
  export type commandeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the commande
     */
    select?: commandeSelect<ExtArgs> | null
    /**
     * The filter to search for the commande to update in case it exists.
     */
    where: commandeWhereUniqueInput
    /**
     * In case the commande found by the `where` argument doesn't exist, create a new commande with this data.
     */
    create: XOR<commandeCreateInput, commandeUncheckedCreateInput>
    /**
     * In case the commande was found with the provided `where` argument, update it with this data.
     */
    update: XOR<commandeUpdateInput, commandeUncheckedUpdateInput>
  }


  /**
   * commande delete
   */
  export type commandeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the commande
     */
    select?: commandeSelect<ExtArgs> | null
    /**
     * Filter which commande to delete.
     */
    where: commandeWhereUniqueInput
  }


  /**
   * commande deleteMany
   */
  export type commandeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which commandes to delete
     */
    where?: commandeWhereInput
  }


  /**
   * commande without action
   */
  export type commandeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the commande
     */
    select?: commandeSelect<ExtArgs> | null
  }



  /**
   * Model facture
   */

  export type AggregateFacture = {
    _count: FactureCountAggregateOutputType | null
    _avg: FactureAvgAggregateOutputType | null
    _sum: FactureSumAggregateOutputType | null
    _min: FactureMinAggregateOutputType | null
    _max: FactureMaxAggregateOutputType | null
  }

  export type FactureAvgAggregateOutputType = {
    IdFactures: number | null
    MontantTotal: Decimal | null
    IdClient: number | null
  }

  export type FactureSumAggregateOutputType = {
    IdFactures: number | null
    MontantTotal: Decimal | null
    IdClient: number | null
  }

  export type FactureMinAggregateOutputType = {
    IdFactures: number | null
    DatedeFacturation: Date | null
    MontantTotal: Decimal | null
    IdClient: number | null
  }

  export type FactureMaxAggregateOutputType = {
    IdFactures: number | null
    DatedeFacturation: Date | null
    MontantTotal: Decimal | null
    IdClient: number | null
  }

  export type FactureCountAggregateOutputType = {
    IdFactures: number
    DatedeFacturation: number
    MontantTotal: number
    IdClient: number
    _all: number
  }


  export type FactureAvgAggregateInputType = {
    IdFactures?: true
    MontantTotal?: true
    IdClient?: true
  }

  export type FactureSumAggregateInputType = {
    IdFactures?: true
    MontantTotal?: true
    IdClient?: true
  }

  export type FactureMinAggregateInputType = {
    IdFactures?: true
    DatedeFacturation?: true
    MontantTotal?: true
    IdClient?: true
  }

  export type FactureMaxAggregateInputType = {
    IdFactures?: true
    DatedeFacturation?: true
    MontantTotal?: true
    IdClient?: true
  }

  export type FactureCountAggregateInputType = {
    IdFactures?: true
    DatedeFacturation?: true
    MontantTotal?: true
    IdClient?: true
    _all?: true
  }

  export type FactureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which facture to aggregate.
     */
    where?: factureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of factures to fetch.
     */
    orderBy?: factureOrderByWithRelationInput | factureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: factureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` factures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` factures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned factures
    **/
    _count?: true | FactureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FactureAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FactureSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FactureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FactureMaxAggregateInputType
  }

  export type GetFactureAggregateType<T extends FactureAggregateArgs> = {
        [P in keyof T & keyof AggregateFacture]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFacture[P]>
      : GetScalarType<T[P], AggregateFacture[P]>
  }




  export type factureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: factureWhereInput
    orderBy?: factureOrderByWithAggregationInput | factureOrderByWithAggregationInput[]
    by: FactureScalarFieldEnum[] | FactureScalarFieldEnum
    having?: factureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FactureCountAggregateInputType | true
    _avg?: FactureAvgAggregateInputType
    _sum?: FactureSumAggregateInputType
    _min?: FactureMinAggregateInputType
    _max?: FactureMaxAggregateInputType
  }

  export type FactureGroupByOutputType = {
    IdFactures: number
    DatedeFacturation: Date
    MontantTotal: Decimal
    IdClient: number
    _count: FactureCountAggregateOutputType | null
    _avg: FactureAvgAggregateOutputType | null
    _sum: FactureSumAggregateOutputType | null
    _min: FactureMinAggregateOutputType | null
    _max: FactureMaxAggregateOutputType | null
  }

  type GetFactureGroupByPayload<T extends factureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FactureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FactureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FactureGroupByOutputType[P]>
            : GetScalarType<T[P], FactureGroupByOutputType[P]>
        }
      >
    >


  export type factureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdFactures?: boolean
    DatedeFacturation?: boolean
    MontantTotal?: boolean
    IdClient?: boolean
  }, ExtArgs["result"]["facture"]>

  export type factureSelectScalar = {
    IdFactures?: boolean
    DatedeFacturation?: boolean
    MontantTotal?: boolean
    IdClient?: boolean
  }


  export type $facturePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "facture"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      IdFactures: number
      DatedeFacturation: Date
      MontantTotal: Prisma.Decimal
      IdClient: number
    }, ExtArgs["result"]["facture"]>
    composites: {}
  }


  type factureGetPayload<S extends boolean | null | undefined | factureDefaultArgs> = $Result.GetResult<Prisma.$facturePayload, S>

  type factureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<factureFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FactureCountAggregateInputType | true
    }

  export interface factureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['facture'], meta: { name: 'facture' } }
    /**
     * Find zero or one Facture that matches the filter.
     * @param {factureFindUniqueArgs} args - Arguments to find a Facture
     * @example
     * // Get one Facture
     * const facture = await prisma.facture.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends factureFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, factureFindUniqueArgs<ExtArgs>>
    ): Prisma__factureClient<$Result.GetResult<Prisma.$facturePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Facture that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {factureFindUniqueOrThrowArgs} args - Arguments to find a Facture
     * @example
     * // Get one Facture
     * const facture = await prisma.facture.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends factureFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, factureFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__factureClient<$Result.GetResult<Prisma.$facturePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Facture that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {factureFindFirstArgs} args - Arguments to find a Facture
     * @example
     * // Get one Facture
     * const facture = await prisma.facture.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends factureFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, factureFindFirstArgs<ExtArgs>>
    ): Prisma__factureClient<$Result.GetResult<Prisma.$facturePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Facture that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {factureFindFirstOrThrowArgs} args - Arguments to find a Facture
     * @example
     * // Get one Facture
     * const facture = await prisma.facture.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends factureFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, factureFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__factureClient<$Result.GetResult<Prisma.$facturePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Factures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {factureFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Factures
     * const factures = await prisma.facture.findMany()
     * 
     * // Get first 10 Factures
     * const factures = await prisma.facture.findMany({ take: 10 })
     * 
     * // Only select the `IdFactures`
     * const factureWithIdFacturesOnly = await prisma.facture.findMany({ select: { IdFactures: true } })
     * 
    **/
    findMany<T extends factureFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, factureFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$facturePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Facture.
     * @param {factureCreateArgs} args - Arguments to create a Facture.
     * @example
     * // Create one Facture
     * const Facture = await prisma.facture.create({
     *   data: {
     *     // ... data to create a Facture
     *   }
     * })
     * 
    **/
    create<T extends factureCreateArgs<ExtArgs>>(
      args: SelectSubset<T, factureCreateArgs<ExtArgs>>
    ): Prisma__factureClient<$Result.GetResult<Prisma.$facturePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Factures.
     *     @param {factureCreateManyArgs} args - Arguments to create many Factures.
     *     @example
     *     // Create many Factures
     *     const facture = await prisma.facture.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends factureCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, factureCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Facture.
     * @param {factureDeleteArgs} args - Arguments to delete one Facture.
     * @example
     * // Delete one Facture
     * const Facture = await prisma.facture.delete({
     *   where: {
     *     // ... filter to delete one Facture
     *   }
     * })
     * 
    **/
    delete<T extends factureDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, factureDeleteArgs<ExtArgs>>
    ): Prisma__factureClient<$Result.GetResult<Prisma.$facturePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Facture.
     * @param {factureUpdateArgs} args - Arguments to update one Facture.
     * @example
     * // Update one Facture
     * const facture = await prisma.facture.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends factureUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, factureUpdateArgs<ExtArgs>>
    ): Prisma__factureClient<$Result.GetResult<Prisma.$facturePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Factures.
     * @param {factureDeleteManyArgs} args - Arguments to filter Factures to delete.
     * @example
     * // Delete a few Factures
     * const { count } = await prisma.facture.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends factureDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, factureDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Factures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {factureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Factures
     * const facture = await prisma.facture.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends factureUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, factureUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Facture.
     * @param {factureUpsertArgs} args - Arguments to update or create a Facture.
     * @example
     * // Update or create a Facture
     * const facture = await prisma.facture.upsert({
     *   create: {
     *     // ... data to create a Facture
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Facture we want to update
     *   }
     * })
    **/
    upsert<T extends factureUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, factureUpsertArgs<ExtArgs>>
    ): Prisma__factureClient<$Result.GetResult<Prisma.$facturePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Factures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {factureCountArgs} args - Arguments to filter Factures to count.
     * @example
     * // Count the number of Factures
     * const count = await prisma.facture.count({
     *   where: {
     *     // ... the filter for the Factures we want to count
     *   }
     * })
    **/
    count<T extends factureCountArgs>(
      args?: Subset<T, factureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FactureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Facture.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FactureAggregateArgs>(args: Subset<T, FactureAggregateArgs>): Prisma.PrismaPromise<GetFactureAggregateType<T>>

    /**
     * Group by Facture.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {factureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends factureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: factureGroupByArgs['orderBy'] }
        : { orderBy?: factureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, factureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFactureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the facture model
   */
  readonly fields: factureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for facture.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__factureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the facture model
   */ 
  interface factureFieldRefs {
    readonly IdFactures: FieldRef<"facture", 'Int'>
    readonly DatedeFacturation: FieldRef<"facture", 'DateTime'>
    readonly MontantTotal: FieldRef<"facture", 'Decimal'>
    readonly IdClient: FieldRef<"facture", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * facture findUnique
   */
  export type factureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the facture
     */
    select?: factureSelect<ExtArgs> | null
    /**
     * Filter, which facture to fetch.
     */
    where: factureWhereUniqueInput
  }


  /**
   * facture findUniqueOrThrow
   */
  export type factureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the facture
     */
    select?: factureSelect<ExtArgs> | null
    /**
     * Filter, which facture to fetch.
     */
    where: factureWhereUniqueInput
  }


  /**
   * facture findFirst
   */
  export type factureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the facture
     */
    select?: factureSelect<ExtArgs> | null
    /**
     * Filter, which facture to fetch.
     */
    where?: factureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of factures to fetch.
     */
    orderBy?: factureOrderByWithRelationInput | factureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for factures.
     */
    cursor?: factureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` factures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` factures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of factures.
     */
    distinct?: FactureScalarFieldEnum | FactureScalarFieldEnum[]
  }


  /**
   * facture findFirstOrThrow
   */
  export type factureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the facture
     */
    select?: factureSelect<ExtArgs> | null
    /**
     * Filter, which facture to fetch.
     */
    where?: factureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of factures to fetch.
     */
    orderBy?: factureOrderByWithRelationInput | factureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for factures.
     */
    cursor?: factureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` factures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` factures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of factures.
     */
    distinct?: FactureScalarFieldEnum | FactureScalarFieldEnum[]
  }


  /**
   * facture findMany
   */
  export type factureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the facture
     */
    select?: factureSelect<ExtArgs> | null
    /**
     * Filter, which factures to fetch.
     */
    where?: factureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of factures to fetch.
     */
    orderBy?: factureOrderByWithRelationInput | factureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing factures.
     */
    cursor?: factureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` factures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` factures.
     */
    skip?: number
    distinct?: FactureScalarFieldEnum | FactureScalarFieldEnum[]
  }


  /**
   * facture create
   */
  export type factureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the facture
     */
    select?: factureSelect<ExtArgs> | null
    /**
     * The data needed to create a facture.
     */
    data: XOR<factureCreateInput, factureUncheckedCreateInput>
  }


  /**
   * facture createMany
   */
  export type factureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many factures.
     */
    data: factureCreateManyInput | factureCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * facture update
   */
  export type factureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the facture
     */
    select?: factureSelect<ExtArgs> | null
    /**
     * The data needed to update a facture.
     */
    data: XOR<factureUpdateInput, factureUncheckedUpdateInput>
    /**
     * Choose, which facture to update.
     */
    where: factureWhereUniqueInput
  }


  /**
   * facture updateMany
   */
  export type factureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update factures.
     */
    data: XOR<factureUpdateManyMutationInput, factureUncheckedUpdateManyInput>
    /**
     * Filter which factures to update
     */
    where?: factureWhereInput
  }


  /**
   * facture upsert
   */
  export type factureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the facture
     */
    select?: factureSelect<ExtArgs> | null
    /**
     * The filter to search for the facture to update in case it exists.
     */
    where: factureWhereUniqueInput
    /**
     * In case the facture found by the `where` argument doesn't exist, create a new facture with this data.
     */
    create: XOR<factureCreateInput, factureUncheckedCreateInput>
    /**
     * In case the facture was found with the provided `where` argument, update it with this data.
     */
    update: XOR<factureUpdateInput, factureUncheckedUpdateInput>
  }


  /**
   * facture delete
   */
  export type factureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the facture
     */
    select?: factureSelect<ExtArgs> | null
    /**
     * Filter which facture to delete.
     */
    where: factureWhereUniqueInput
  }


  /**
   * facture deleteMany
   */
  export type factureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which factures to delete
     */
    where?: factureWhereInput
  }


  /**
   * facture without action
   */
  export type factureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the facture
     */
    select?: factureSelect<ExtArgs> | null
  }



  /**
   * Model inclut
   */

  export type AggregateInclut = {
    _count: InclutCountAggregateOutputType | null
    _avg: InclutAvgAggregateOutputType | null
    _sum: InclutSumAggregateOutputType | null
    _min: InclutMinAggregateOutputType | null
    _max: InclutMaxAggregateOutputType | null
  }

  export type InclutAvgAggregateOutputType = {
    IdMoto: number | null
    IdCommandes: number | null
  }

  export type InclutSumAggregateOutputType = {
    IdMoto: number | null
    IdCommandes: number | null
  }

  export type InclutMinAggregateOutputType = {
    IdMoto: number | null
    IdCommandes: number | null
  }

  export type InclutMaxAggregateOutputType = {
    IdMoto: number | null
    IdCommandes: number | null
  }

  export type InclutCountAggregateOutputType = {
    IdMoto: number
    IdCommandes: number
    _all: number
  }


  export type InclutAvgAggregateInputType = {
    IdMoto?: true
    IdCommandes?: true
  }

  export type InclutSumAggregateInputType = {
    IdMoto?: true
    IdCommandes?: true
  }

  export type InclutMinAggregateInputType = {
    IdMoto?: true
    IdCommandes?: true
  }

  export type InclutMaxAggregateInputType = {
    IdMoto?: true
    IdCommandes?: true
  }

  export type InclutCountAggregateInputType = {
    IdMoto?: true
    IdCommandes?: true
    _all?: true
  }

  export type InclutAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which inclut to aggregate.
     */
    where?: inclutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of incluts to fetch.
     */
    orderBy?: inclutOrderByWithRelationInput | inclutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inclutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` incluts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` incluts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned incluts
    **/
    _count?: true | InclutCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InclutAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InclutSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InclutMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InclutMaxAggregateInputType
  }

  export type GetInclutAggregateType<T extends InclutAggregateArgs> = {
        [P in keyof T & keyof AggregateInclut]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInclut[P]>
      : GetScalarType<T[P], AggregateInclut[P]>
  }




  export type inclutGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: inclutWhereInput
    orderBy?: inclutOrderByWithAggregationInput | inclutOrderByWithAggregationInput[]
    by: InclutScalarFieldEnum[] | InclutScalarFieldEnum
    having?: inclutScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InclutCountAggregateInputType | true
    _avg?: InclutAvgAggregateInputType
    _sum?: InclutSumAggregateInputType
    _min?: InclutMinAggregateInputType
    _max?: InclutMaxAggregateInputType
  }

  export type InclutGroupByOutputType = {
    IdMoto: number
    IdCommandes: number
    _count: InclutCountAggregateOutputType | null
    _avg: InclutAvgAggregateOutputType | null
    _sum: InclutSumAggregateOutputType | null
    _min: InclutMinAggregateOutputType | null
    _max: InclutMaxAggregateOutputType | null
  }

  type GetInclutGroupByPayload<T extends inclutGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InclutGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InclutGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InclutGroupByOutputType[P]>
            : GetScalarType<T[P], InclutGroupByOutputType[P]>
        }
      >
    >


  export type inclutSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdMoto?: boolean
    IdCommandes?: boolean
  }, ExtArgs["result"]["inclut"]>

  export type inclutSelectScalar = {
    IdMoto?: boolean
    IdCommandes?: boolean
  }


  export type $inclutPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "inclut"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      IdMoto: number
      IdCommandes: number
    }, ExtArgs["result"]["inclut"]>
    composites: {}
  }


  type inclutGetPayload<S extends boolean | null | undefined | inclutDefaultArgs> = $Result.GetResult<Prisma.$inclutPayload, S>

  type inclutCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<inclutFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InclutCountAggregateInputType | true
    }

  export interface inclutDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inclut'], meta: { name: 'inclut' } }
    /**
     * Find zero or one Inclut that matches the filter.
     * @param {inclutFindUniqueArgs} args - Arguments to find a Inclut
     * @example
     * // Get one Inclut
     * const inclut = await prisma.inclut.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends inclutFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, inclutFindUniqueArgs<ExtArgs>>
    ): Prisma__inclutClient<$Result.GetResult<Prisma.$inclutPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Inclut that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {inclutFindUniqueOrThrowArgs} args - Arguments to find a Inclut
     * @example
     * // Get one Inclut
     * const inclut = await prisma.inclut.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends inclutFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inclutFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__inclutClient<$Result.GetResult<Prisma.$inclutPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Inclut that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inclutFindFirstArgs} args - Arguments to find a Inclut
     * @example
     * // Get one Inclut
     * const inclut = await prisma.inclut.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends inclutFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, inclutFindFirstArgs<ExtArgs>>
    ): Prisma__inclutClient<$Result.GetResult<Prisma.$inclutPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Inclut that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inclutFindFirstOrThrowArgs} args - Arguments to find a Inclut
     * @example
     * // Get one Inclut
     * const inclut = await prisma.inclut.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends inclutFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inclutFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__inclutClient<$Result.GetResult<Prisma.$inclutPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Incluts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inclutFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Incluts
     * const incluts = await prisma.inclut.findMany()
     * 
     * // Get first 10 Incluts
     * const incluts = await prisma.inclut.findMany({ take: 10 })
     * 
     * // Only select the `IdMoto`
     * const inclutWithIdMotoOnly = await prisma.inclut.findMany({ select: { IdMoto: true } })
     * 
    **/
    findMany<T extends inclutFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inclutFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inclutPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Inclut.
     * @param {inclutCreateArgs} args - Arguments to create a Inclut.
     * @example
     * // Create one Inclut
     * const Inclut = await prisma.inclut.create({
     *   data: {
     *     // ... data to create a Inclut
     *   }
     * })
     * 
    **/
    create<T extends inclutCreateArgs<ExtArgs>>(
      args: SelectSubset<T, inclutCreateArgs<ExtArgs>>
    ): Prisma__inclutClient<$Result.GetResult<Prisma.$inclutPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Incluts.
     *     @param {inclutCreateManyArgs} args - Arguments to create many Incluts.
     *     @example
     *     // Create many Incluts
     *     const inclut = await prisma.inclut.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends inclutCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inclutCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inclut.
     * @param {inclutDeleteArgs} args - Arguments to delete one Inclut.
     * @example
     * // Delete one Inclut
     * const Inclut = await prisma.inclut.delete({
     *   where: {
     *     // ... filter to delete one Inclut
     *   }
     * })
     * 
    **/
    delete<T extends inclutDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, inclutDeleteArgs<ExtArgs>>
    ): Prisma__inclutClient<$Result.GetResult<Prisma.$inclutPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Inclut.
     * @param {inclutUpdateArgs} args - Arguments to update one Inclut.
     * @example
     * // Update one Inclut
     * const inclut = await prisma.inclut.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends inclutUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, inclutUpdateArgs<ExtArgs>>
    ): Prisma__inclutClient<$Result.GetResult<Prisma.$inclutPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Incluts.
     * @param {inclutDeleteManyArgs} args - Arguments to filter Incluts to delete.
     * @example
     * // Delete a few Incluts
     * const { count } = await prisma.inclut.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends inclutDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inclutDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Incluts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inclutUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Incluts
     * const inclut = await prisma.inclut.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends inclutUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, inclutUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inclut.
     * @param {inclutUpsertArgs} args - Arguments to update or create a Inclut.
     * @example
     * // Update or create a Inclut
     * const inclut = await prisma.inclut.upsert({
     *   create: {
     *     // ... data to create a Inclut
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inclut we want to update
     *   }
     * })
    **/
    upsert<T extends inclutUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, inclutUpsertArgs<ExtArgs>>
    ): Prisma__inclutClient<$Result.GetResult<Prisma.$inclutPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Incluts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inclutCountArgs} args - Arguments to filter Incluts to count.
     * @example
     * // Count the number of Incluts
     * const count = await prisma.inclut.count({
     *   where: {
     *     // ... the filter for the Incluts we want to count
     *   }
     * })
    **/
    count<T extends inclutCountArgs>(
      args?: Subset<T, inclutCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InclutCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inclut.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InclutAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InclutAggregateArgs>(args: Subset<T, InclutAggregateArgs>): Prisma.PrismaPromise<GetInclutAggregateType<T>>

    /**
     * Group by Inclut.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inclutGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inclutGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inclutGroupByArgs['orderBy'] }
        : { orderBy?: inclutGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inclutGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInclutGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inclut model
   */
  readonly fields: inclutFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inclut.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inclutClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the inclut model
   */ 
  interface inclutFieldRefs {
    readonly IdMoto: FieldRef<"inclut", 'Int'>
    readonly IdCommandes: FieldRef<"inclut", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * inclut findUnique
   */
  export type inclutFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inclut
     */
    select?: inclutSelect<ExtArgs> | null
    /**
     * Filter, which inclut to fetch.
     */
    where: inclutWhereUniqueInput
  }


  /**
   * inclut findUniqueOrThrow
   */
  export type inclutFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inclut
     */
    select?: inclutSelect<ExtArgs> | null
    /**
     * Filter, which inclut to fetch.
     */
    where: inclutWhereUniqueInput
  }


  /**
   * inclut findFirst
   */
  export type inclutFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inclut
     */
    select?: inclutSelect<ExtArgs> | null
    /**
     * Filter, which inclut to fetch.
     */
    where?: inclutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of incluts to fetch.
     */
    orderBy?: inclutOrderByWithRelationInput | inclutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for incluts.
     */
    cursor?: inclutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` incluts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` incluts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of incluts.
     */
    distinct?: InclutScalarFieldEnum | InclutScalarFieldEnum[]
  }


  /**
   * inclut findFirstOrThrow
   */
  export type inclutFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inclut
     */
    select?: inclutSelect<ExtArgs> | null
    /**
     * Filter, which inclut to fetch.
     */
    where?: inclutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of incluts to fetch.
     */
    orderBy?: inclutOrderByWithRelationInput | inclutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for incluts.
     */
    cursor?: inclutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` incluts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` incluts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of incluts.
     */
    distinct?: InclutScalarFieldEnum | InclutScalarFieldEnum[]
  }


  /**
   * inclut findMany
   */
  export type inclutFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inclut
     */
    select?: inclutSelect<ExtArgs> | null
    /**
     * Filter, which incluts to fetch.
     */
    where?: inclutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of incluts to fetch.
     */
    orderBy?: inclutOrderByWithRelationInput | inclutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing incluts.
     */
    cursor?: inclutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` incluts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` incluts.
     */
    skip?: number
    distinct?: InclutScalarFieldEnum | InclutScalarFieldEnum[]
  }


  /**
   * inclut create
   */
  export type inclutCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inclut
     */
    select?: inclutSelect<ExtArgs> | null
    /**
     * The data needed to create a inclut.
     */
    data: XOR<inclutCreateInput, inclutUncheckedCreateInput>
  }


  /**
   * inclut createMany
   */
  export type inclutCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many incluts.
     */
    data: inclutCreateManyInput | inclutCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * inclut update
   */
  export type inclutUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inclut
     */
    select?: inclutSelect<ExtArgs> | null
    /**
     * The data needed to update a inclut.
     */
    data: XOR<inclutUpdateInput, inclutUncheckedUpdateInput>
    /**
     * Choose, which inclut to update.
     */
    where: inclutWhereUniqueInput
  }


  /**
   * inclut updateMany
   */
  export type inclutUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update incluts.
     */
    data: XOR<inclutUpdateManyMutationInput, inclutUncheckedUpdateManyInput>
    /**
     * Filter which incluts to update
     */
    where?: inclutWhereInput
  }


  /**
   * inclut upsert
   */
  export type inclutUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inclut
     */
    select?: inclutSelect<ExtArgs> | null
    /**
     * The filter to search for the inclut to update in case it exists.
     */
    where: inclutWhereUniqueInput
    /**
     * In case the inclut found by the `where` argument doesn't exist, create a new inclut with this data.
     */
    create: XOR<inclutCreateInput, inclutUncheckedCreateInput>
    /**
     * In case the inclut was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inclutUpdateInput, inclutUncheckedUpdateInput>
  }


  /**
   * inclut delete
   */
  export type inclutDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inclut
     */
    select?: inclutSelect<ExtArgs> | null
    /**
     * Filter which inclut to delete.
     */
    where: inclutWhereUniqueInput
  }


  /**
   * inclut deleteMany
   */
  export type inclutDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which incluts to delete
     */
    where?: inclutWhereInput
  }


  /**
   * inclut without action
   */
  export type inclutDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inclut
     */
    select?: inclutSelect<ExtArgs> | null
  }



  /**
   * Model methodedepaiement
   */

  export type AggregateMethodedepaiement = {
    _count: MethodedepaiementCountAggregateOutputType | null
    _avg: MethodedepaiementAvgAggregateOutputType | null
    _sum: MethodedepaiementSumAggregateOutputType | null
    _min: MethodedepaiementMinAggregateOutputType | null
    _max: MethodedepaiementMaxAggregateOutputType | null
  }

  export type MethodedepaiementAvgAggregateOutputType = {
    IdPaiement: number | null
  }

  export type MethodedepaiementSumAggregateOutputType = {
    IdPaiement: number | null
  }

  export type MethodedepaiementMinAggregateOutputType = {
    IdPaiement: number | null
    TypePaiement: string | null
    InformationsDePaiement: string | null
  }

  export type MethodedepaiementMaxAggregateOutputType = {
    IdPaiement: number | null
    TypePaiement: string | null
    InformationsDePaiement: string | null
  }

  export type MethodedepaiementCountAggregateOutputType = {
    IdPaiement: number
    TypePaiement: number
    InformationsDePaiement: number
    _all: number
  }


  export type MethodedepaiementAvgAggregateInputType = {
    IdPaiement?: true
  }

  export type MethodedepaiementSumAggregateInputType = {
    IdPaiement?: true
  }

  export type MethodedepaiementMinAggregateInputType = {
    IdPaiement?: true
    TypePaiement?: true
    InformationsDePaiement?: true
  }

  export type MethodedepaiementMaxAggregateInputType = {
    IdPaiement?: true
    TypePaiement?: true
    InformationsDePaiement?: true
  }

  export type MethodedepaiementCountAggregateInputType = {
    IdPaiement?: true
    TypePaiement?: true
    InformationsDePaiement?: true
    _all?: true
  }

  export type MethodedepaiementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which methodedepaiement to aggregate.
     */
    where?: methodedepaiementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of methodedepaiements to fetch.
     */
    orderBy?: methodedepaiementOrderByWithRelationInput | methodedepaiementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: methodedepaiementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` methodedepaiements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` methodedepaiements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned methodedepaiements
    **/
    _count?: true | MethodedepaiementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MethodedepaiementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MethodedepaiementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MethodedepaiementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MethodedepaiementMaxAggregateInputType
  }

  export type GetMethodedepaiementAggregateType<T extends MethodedepaiementAggregateArgs> = {
        [P in keyof T & keyof AggregateMethodedepaiement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMethodedepaiement[P]>
      : GetScalarType<T[P], AggregateMethodedepaiement[P]>
  }




  export type methodedepaiementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: methodedepaiementWhereInput
    orderBy?: methodedepaiementOrderByWithAggregationInput | methodedepaiementOrderByWithAggregationInput[]
    by: MethodedepaiementScalarFieldEnum[] | MethodedepaiementScalarFieldEnum
    having?: methodedepaiementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MethodedepaiementCountAggregateInputType | true
    _avg?: MethodedepaiementAvgAggregateInputType
    _sum?: MethodedepaiementSumAggregateInputType
    _min?: MethodedepaiementMinAggregateInputType
    _max?: MethodedepaiementMaxAggregateInputType
  }

  export type MethodedepaiementGroupByOutputType = {
    IdPaiement: number
    TypePaiement: string
    InformationsDePaiement: string
    _count: MethodedepaiementCountAggregateOutputType | null
    _avg: MethodedepaiementAvgAggregateOutputType | null
    _sum: MethodedepaiementSumAggregateOutputType | null
    _min: MethodedepaiementMinAggregateOutputType | null
    _max: MethodedepaiementMaxAggregateOutputType | null
  }

  type GetMethodedepaiementGroupByPayload<T extends methodedepaiementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MethodedepaiementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MethodedepaiementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MethodedepaiementGroupByOutputType[P]>
            : GetScalarType<T[P], MethodedepaiementGroupByOutputType[P]>
        }
      >
    >


  export type methodedepaiementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdPaiement?: boolean
    TypePaiement?: boolean
    InformationsDePaiement?: boolean
  }, ExtArgs["result"]["methodedepaiement"]>

  export type methodedepaiementSelectScalar = {
    IdPaiement?: boolean
    TypePaiement?: boolean
    InformationsDePaiement?: boolean
  }


  export type $methodedepaiementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "methodedepaiement"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      IdPaiement: number
      TypePaiement: string
      InformationsDePaiement: string
    }, ExtArgs["result"]["methodedepaiement"]>
    composites: {}
  }


  type methodedepaiementGetPayload<S extends boolean | null | undefined | methodedepaiementDefaultArgs> = $Result.GetResult<Prisma.$methodedepaiementPayload, S>

  type methodedepaiementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<methodedepaiementFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MethodedepaiementCountAggregateInputType | true
    }

  export interface methodedepaiementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['methodedepaiement'], meta: { name: 'methodedepaiement' } }
    /**
     * Find zero or one Methodedepaiement that matches the filter.
     * @param {methodedepaiementFindUniqueArgs} args - Arguments to find a Methodedepaiement
     * @example
     * // Get one Methodedepaiement
     * const methodedepaiement = await prisma.methodedepaiement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends methodedepaiementFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, methodedepaiementFindUniqueArgs<ExtArgs>>
    ): Prisma__methodedepaiementClient<$Result.GetResult<Prisma.$methodedepaiementPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Methodedepaiement that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {methodedepaiementFindUniqueOrThrowArgs} args - Arguments to find a Methodedepaiement
     * @example
     * // Get one Methodedepaiement
     * const methodedepaiement = await prisma.methodedepaiement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends methodedepaiementFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, methodedepaiementFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__methodedepaiementClient<$Result.GetResult<Prisma.$methodedepaiementPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Methodedepaiement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {methodedepaiementFindFirstArgs} args - Arguments to find a Methodedepaiement
     * @example
     * // Get one Methodedepaiement
     * const methodedepaiement = await prisma.methodedepaiement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends methodedepaiementFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, methodedepaiementFindFirstArgs<ExtArgs>>
    ): Prisma__methodedepaiementClient<$Result.GetResult<Prisma.$methodedepaiementPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Methodedepaiement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {methodedepaiementFindFirstOrThrowArgs} args - Arguments to find a Methodedepaiement
     * @example
     * // Get one Methodedepaiement
     * const methodedepaiement = await prisma.methodedepaiement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends methodedepaiementFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, methodedepaiementFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__methodedepaiementClient<$Result.GetResult<Prisma.$methodedepaiementPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Methodedepaiements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {methodedepaiementFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Methodedepaiements
     * const methodedepaiements = await prisma.methodedepaiement.findMany()
     * 
     * // Get first 10 Methodedepaiements
     * const methodedepaiements = await prisma.methodedepaiement.findMany({ take: 10 })
     * 
     * // Only select the `IdPaiement`
     * const methodedepaiementWithIdPaiementOnly = await prisma.methodedepaiement.findMany({ select: { IdPaiement: true } })
     * 
    **/
    findMany<T extends methodedepaiementFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, methodedepaiementFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$methodedepaiementPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Methodedepaiement.
     * @param {methodedepaiementCreateArgs} args - Arguments to create a Methodedepaiement.
     * @example
     * // Create one Methodedepaiement
     * const Methodedepaiement = await prisma.methodedepaiement.create({
     *   data: {
     *     // ... data to create a Methodedepaiement
     *   }
     * })
     * 
    **/
    create<T extends methodedepaiementCreateArgs<ExtArgs>>(
      args: SelectSubset<T, methodedepaiementCreateArgs<ExtArgs>>
    ): Prisma__methodedepaiementClient<$Result.GetResult<Prisma.$methodedepaiementPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Methodedepaiements.
     *     @param {methodedepaiementCreateManyArgs} args - Arguments to create many Methodedepaiements.
     *     @example
     *     // Create many Methodedepaiements
     *     const methodedepaiement = await prisma.methodedepaiement.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends methodedepaiementCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, methodedepaiementCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Methodedepaiement.
     * @param {methodedepaiementDeleteArgs} args - Arguments to delete one Methodedepaiement.
     * @example
     * // Delete one Methodedepaiement
     * const Methodedepaiement = await prisma.methodedepaiement.delete({
     *   where: {
     *     // ... filter to delete one Methodedepaiement
     *   }
     * })
     * 
    **/
    delete<T extends methodedepaiementDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, methodedepaiementDeleteArgs<ExtArgs>>
    ): Prisma__methodedepaiementClient<$Result.GetResult<Prisma.$methodedepaiementPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Methodedepaiement.
     * @param {methodedepaiementUpdateArgs} args - Arguments to update one Methodedepaiement.
     * @example
     * // Update one Methodedepaiement
     * const methodedepaiement = await prisma.methodedepaiement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends methodedepaiementUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, methodedepaiementUpdateArgs<ExtArgs>>
    ): Prisma__methodedepaiementClient<$Result.GetResult<Prisma.$methodedepaiementPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Methodedepaiements.
     * @param {methodedepaiementDeleteManyArgs} args - Arguments to filter Methodedepaiements to delete.
     * @example
     * // Delete a few Methodedepaiements
     * const { count } = await prisma.methodedepaiement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends methodedepaiementDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, methodedepaiementDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Methodedepaiements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {methodedepaiementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Methodedepaiements
     * const methodedepaiement = await prisma.methodedepaiement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends methodedepaiementUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, methodedepaiementUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Methodedepaiement.
     * @param {methodedepaiementUpsertArgs} args - Arguments to update or create a Methodedepaiement.
     * @example
     * // Update or create a Methodedepaiement
     * const methodedepaiement = await prisma.methodedepaiement.upsert({
     *   create: {
     *     // ... data to create a Methodedepaiement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Methodedepaiement we want to update
     *   }
     * })
    **/
    upsert<T extends methodedepaiementUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, methodedepaiementUpsertArgs<ExtArgs>>
    ): Prisma__methodedepaiementClient<$Result.GetResult<Prisma.$methodedepaiementPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Methodedepaiements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {methodedepaiementCountArgs} args - Arguments to filter Methodedepaiements to count.
     * @example
     * // Count the number of Methodedepaiements
     * const count = await prisma.methodedepaiement.count({
     *   where: {
     *     // ... the filter for the Methodedepaiements we want to count
     *   }
     * })
    **/
    count<T extends methodedepaiementCountArgs>(
      args?: Subset<T, methodedepaiementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MethodedepaiementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Methodedepaiement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MethodedepaiementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MethodedepaiementAggregateArgs>(args: Subset<T, MethodedepaiementAggregateArgs>): Prisma.PrismaPromise<GetMethodedepaiementAggregateType<T>>

    /**
     * Group by Methodedepaiement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {methodedepaiementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends methodedepaiementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: methodedepaiementGroupByArgs['orderBy'] }
        : { orderBy?: methodedepaiementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, methodedepaiementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMethodedepaiementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the methodedepaiement model
   */
  readonly fields: methodedepaiementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for methodedepaiement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__methodedepaiementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the methodedepaiement model
   */ 
  interface methodedepaiementFieldRefs {
    readonly IdPaiement: FieldRef<"methodedepaiement", 'Int'>
    readonly TypePaiement: FieldRef<"methodedepaiement", 'String'>
    readonly InformationsDePaiement: FieldRef<"methodedepaiement", 'String'>
  }
    

  // Custom InputTypes

  /**
   * methodedepaiement findUnique
   */
  export type methodedepaiementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the methodedepaiement
     */
    select?: methodedepaiementSelect<ExtArgs> | null
    /**
     * Filter, which methodedepaiement to fetch.
     */
    where: methodedepaiementWhereUniqueInput
  }


  /**
   * methodedepaiement findUniqueOrThrow
   */
  export type methodedepaiementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the methodedepaiement
     */
    select?: methodedepaiementSelect<ExtArgs> | null
    /**
     * Filter, which methodedepaiement to fetch.
     */
    where: methodedepaiementWhereUniqueInput
  }


  /**
   * methodedepaiement findFirst
   */
  export type methodedepaiementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the methodedepaiement
     */
    select?: methodedepaiementSelect<ExtArgs> | null
    /**
     * Filter, which methodedepaiement to fetch.
     */
    where?: methodedepaiementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of methodedepaiements to fetch.
     */
    orderBy?: methodedepaiementOrderByWithRelationInput | methodedepaiementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for methodedepaiements.
     */
    cursor?: methodedepaiementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` methodedepaiements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` methodedepaiements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of methodedepaiements.
     */
    distinct?: MethodedepaiementScalarFieldEnum | MethodedepaiementScalarFieldEnum[]
  }


  /**
   * methodedepaiement findFirstOrThrow
   */
  export type methodedepaiementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the methodedepaiement
     */
    select?: methodedepaiementSelect<ExtArgs> | null
    /**
     * Filter, which methodedepaiement to fetch.
     */
    where?: methodedepaiementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of methodedepaiements to fetch.
     */
    orderBy?: methodedepaiementOrderByWithRelationInput | methodedepaiementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for methodedepaiements.
     */
    cursor?: methodedepaiementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` methodedepaiements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` methodedepaiements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of methodedepaiements.
     */
    distinct?: MethodedepaiementScalarFieldEnum | MethodedepaiementScalarFieldEnum[]
  }


  /**
   * methodedepaiement findMany
   */
  export type methodedepaiementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the methodedepaiement
     */
    select?: methodedepaiementSelect<ExtArgs> | null
    /**
     * Filter, which methodedepaiements to fetch.
     */
    where?: methodedepaiementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of methodedepaiements to fetch.
     */
    orderBy?: methodedepaiementOrderByWithRelationInput | methodedepaiementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing methodedepaiements.
     */
    cursor?: methodedepaiementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` methodedepaiements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` methodedepaiements.
     */
    skip?: number
    distinct?: MethodedepaiementScalarFieldEnum | MethodedepaiementScalarFieldEnum[]
  }


  /**
   * methodedepaiement create
   */
  export type methodedepaiementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the methodedepaiement
     */
    select?: methodedepaiementSelect<ExtArgs> | null
    /**
     * The data needed to create a methodedepaiement.
     */
    data: XOR<methodedepaiementCreateInput, methodedepaiementUncheckedCreateInput>
  }


  /**
   * methodedepaiement createMany
   */
  export type methodedepaiementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many methodedepaiements.
     */
    data: methodedepaiementCreateManyInput | methodedepaiementCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * methodedepaiement update
   */
  export type methodedepaiementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the methodedepaiement
     */
    select?: methodedepaiementSelect<ExtArgs> | null
    /**
     * The data needed to update a methodedepaiement.
     */
    data: XOR<methodedepaiementUpdateInput, methodedepaiementUncheckedUpdateInput>
    /**
     * Choose, which methodedepaiement to update.
     */
    where: methodedepaiementWhereUniqueInput
  }


  /**
   * methodedepaiement updateMany
   */
  export type methodedepaiementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update methodedepaiements.
     */
    data: XOR<methodedepaiementUpdateManyMutationInput, methodedepaiementUncheckedUpdateManyInput>
    /**
     * Filter which methodedepaiements to update
     */
    where?: methodedepaiementWhereInput
  }


  /**
   * methodedepaiement upsert
   */
  export type methodedepaiementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the methodedepaiement
     */
    select?: methodedepaiementSelect<ExtArgs> | null
    /**
     * The filter to search for the methodedepaiement to update in case it exists.
     */
    where: methodedepaiementWhereUniqueInput
    /**
     * In case the methodedepaiement found by the `where` argument doesn't exist, create a new methodedepaiement with this data.
     */
    create: XOR<methodedepaiementCreateInput, methodedepaiementUncheckedCreateInput>
    /**
     * In case the methodedepaiement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<methodedepaiementUpdateInput, methodedepaiementUncheckedUpdateInput>
  }


  /**
   * methodedepaiement delete
   */
  export type methodedepaiementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the methodedepaiement
     */
    select?: methodedepaiementSelect<ExtArgs> | null
    /**
     * Filter which methodedepaiement to delete.
     */
    where: methodedepaiementWhereUniqueInput
  }


  /**
   * methodedepaiement deleteMany
   */
  export type methodedepaiementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which methodedepaiements to delete
     */
    where?: methodedepaiementWhereInput
  }


  /**
   * methodedepaiement without action
   */
  export type methodedepaiementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the methodedepaiement
     */
    select?: methodedepaiementSelect<ExtArgs> | null
  }



  /**
   * Model motos
   */

  export type AggregateMotos = {
    _count: MotosCountAggregateOutputType | null
    _avg: MotosAvgAggregateOutputType | null
    _sum: MotosSumAggregateOutputType | null
    _min: MotosMinAggregateOutputType | null
    _max: MotosMaxAggregateOutputType | null
  }

  export type MotosAvgAggregateOutputType = {
    IdMoto: number | null
    Prix: Decimal | null
    Stock: number | null
  }

  export type MotosSumAggregateOutputType = {
    IdMoto: number | null
    Prix: Decimal | null
    Stock: number | null
  }

  export type MotosMinAggregateOutputType = {
    IdMoto: number | null
    NomMoto: string | null
    Constructeur: string | null
    Modele: string | null
    DescriptionDuProduit: string | null
    Prix: Decimal | null
    Stock: number | null
  }

  export type MotosMaxAggregateOutputType = {
    IdMoto: number | null
    NomMoto: string | null
    Constructeur: string | null
    Modele: string | null
    DescriptionDuProduit: string | null
    Prix: Decimal | null
    Stock: number | null
  }

  export type MotosCountAggregateOutputType = {
    IdMoto: number
    NomMoto: number
    Constructeur: number
    Modele: number
    DescriptionDuProduit: number
    Prix: number
    Stock: number
    _all: number
  }


  export type MotosAvgAggregateInputType = {
    IdMoto?: true
    Prix?: true
    Stock?: true
  }

  export type MotosSumAggregateInputType = {
    IdMoto?: true
    Prix?: true
    Stock?: true
  }

  export type MotosMinAggregateInputType = {
    IdMoto?: true
    NomMoto?: true
    Constructeur?: true
    Modele?: true
    DescriptionDuProduit?: true
    Prix?: true
    Stock?: true
  }

  export type MotosMaxAggregateInputType = {
    IdMoto?: true
    NomMoto?: true
    Constructeur?: true
    Modele?: true
    DescriptionDuProduit?: true
    Prix?: true
    Stock?: true
  }

  export type MotosCountAggregateInputType = {
    IdMoto?: true
    NomMoto?: true
    Constructeur?: true
    Modele?: true
    DescriptionDuProduit?: true
    Prix?: true
    Stock?: true
    _all?: true
  }

  export type MotosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which motos to aggregate.
     */
    where?: motosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of motos to fetch.
     */
    orderBy?: motosOrderByWithRelationInput | motosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: motosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` motos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` motos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned motos
    **/
    _count?: true | MotosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MotosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MotosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MotosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MotosMaxAggregateInputType
  }

  export type GetMotosAggregateType<T extends MotosAggregateArgs> = {
        [P in keyof T & keyof AggregateMotos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMotos[P]>
      : GetScalarType<T[P], AggregateMotos[P]>
  }




  export type motosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: motosWhereInput
    orderBy?: motosOrderByWithAggregationInput | motosOrderByWithAggregationInput[]
    by: MotosScalarFieldEnum[] | MotosScalarFieldEnum
    having?: motosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MotosCountAggregateInputType | true
    _avg?: MotosAvgAggregateInputType
    _sum?: MotosSumAggregateInputType
    _min?: MotosMinAggregateInputType
    _max?: MotosMaxAggregateInputType
  }

  export type MotosGroupByOutputType = {
    IdMoto: number
    NomMoto: string
    Constructeur: string
    Modele: string
    DescriptionDuProduit: string
    Prix: Decimal
    Stock: number
    _count: MotosCountAggregateOutputType | null
    _avg: MotosAvgAggregateOutputType | null
    _sum: MotosSumAggregateOutputType | null
    _min: MotosMinAggregateOutputType | null
    _max: MotosMaxAggregateOutputType | null
  }

  type GetMotosGroupByPayload<T extends motosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MotosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MotosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MotosGroupByOutputType[P]>
            : GetScalarType<T[P], MotosGroupByOutputType[P]>
        }
      >
    >


  export type motosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdMoto?: boolean
    NomMoto?: boolean
    Constructeur?: boolean
    Modele?: boolean
    DescriptionDuProduit?: boolean
    Prix?: boolean
    Stock?: boolean
  }, ExtArgs["result"]["motos"]>

  export type motosSelectScalar = {
    IdMoto?: boolean
    NomMoto?: boolean
    Constructeur?: boolean
    Modele?: boolean
    DescriptionDuProduit?: boolean
    Prix?: boolean
    Stock?: boolean
  }


  export type $motosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "motos"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      IdMoto: number
      NomMoto: string
      Constructeur: string
      Modele: string
      DescriptionDuProduit: string
      Prix: Prisma.Decimal
      Stock: number
    }, ExtArgs["result"]["motos"]>
    composites: {}
  }


  type motosGetPayload<S extends boolean | null | undefined | motosDefaultArgs> = $Result.GetResult<Prisma.$motosPayload, S>

  type motosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<motosFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MotosCountAggregateInputType | true
    }

  export interface motosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['motos'], meta: { name: 'motos' } }
    /**
     * Find zero or one Motos that matches the filter.
     * @param {motosFindUniqueArgs} args - Arguments to find a Motos
     * @example
     * // Get one Motos
     * const motos = await prisma.motos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends motosFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, motosFindUniqueArgs<ExtArgs>>
    ): Prisma__motosClient<$Result.GetResult<Prisma.$motosPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Motos that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {motosFindUniqueOrThrowArgs} args - Arguments to find a Motos
     * @example
     * // Get one Motos
     * const motos = await prisma.motos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends motosFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, motosFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__motosClient<$Result.GetResult<Prisma.$motosPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Motos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {motosFindFirstArgs} args - Arguments to find a Motos
     * @example
     * // Get one Motos
     * const motos = await prisma.motos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends motosFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, motosFindFirstArgs<ExtArgs>>
    ): Prisma__motosClient<$Result.GetResult<Prisma.$motosPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Motos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {motosFindFirstOrThrowArgs} args - Arguments to find a Motos
     * @example
     * // Get one Motos
     * const motos = await prisma.motos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends motosFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, motosFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__motosClient<$Result.GetResult<Prisma.$motosPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Motos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {motosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Motos
     * const motos = await prisma.motos.findMany()
     * 
     * // Get first 10 Motos
     * const motos = await prisma.motos.findMany({ take: 10 })
     * 
     * // Only select the `IdMoto`
     * const motosWithIdMotoOnly = await prisma.motos.findMany({ select: { IdMoto: true } })
     * 
    **/
    findMany<T extends motosFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, motosFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$motosPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Motos.
     * @param {motosCreateArgs} args - Arguments to create a Motos.
     * @example
     * // Create one Motos
     * const Motos = await prisma.motos.create({
     *   data: {
     *     // ... data to create a Motos
     *   }
     * })
     * 
    **/
    create<T extends motosCreateArgs<ExtArgs>>(
      args: SelectSubset<T, motosCreateArgs<ExtArgs>>
    ): Prisma__motosClient<$Result.GetResult<Prisma.$motosPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Motos.
     *     @param {motosCreateManyArgs} args - Arguments to create many Motos.
     *     @example
     *     // Create many Motos
     *     const motos = await prisma.motos.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends motosCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, motosCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Motos.
     * @param {motosDeleteArgs} args - Arguments to delete one Motos.
     * @example
     * // Delete one Motos
     * const Motos = await prisma.motos.delete({
     *   where: {
     *     // ... filter to delete one Motos
     *   }
     * })
     * 
    **/
    delete<T extends motosDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, motosDeleteArgs<ExtArgs>>
    ): Prisma__motosClient<$Result.GetResult<Prisma.$motosPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Motos.
     * @param {motosUpdateArgs} args - Arguments to update one Motos.
     * @example
     * // Update one Motos
     * const motos = await prisma.motos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends motosUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, motosUpdateArgs<ExtArgs>>
    ): Prisma__motosClient<$Result.GetResult<Prisma.$motosPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Motos.
     * @param {motosDeleteManyArgs} args - Arguments to filter Motos to delete.
     * @example
     * // Delete a few Motos
     * const { count } = await prisma.motos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends motosDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, motosDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Motos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {motosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Motos
     * const motos = await prisma.motos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends motosUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, motosUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Motos.
     * @param {motosUpsertArgs} args - Arguments to update or create a Motos.
     * @example
     * // Update or create a Motos
     * const motos = await prisma.motos.upsert({
     *   create: {
     *     // ... data to create a Motos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Motos we want to update
     *   }
     * })
    **/
    upsert<T extends motosUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, motosUpsertArgs<ExtArgs>>
    ): Prisma__motosClient<$Result.GetResult<Prisma.$motosPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Motos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {motosCountArgs} args - Arguments to filter Motos to count.
     * @example
     * // Count the number of Motos
     * const count = await prisma.motos.count({
     *   where: {
     *     // ... the filter for the Motos we want to count
     *   }
     * })
    **/
    count<T extends motosCountArgs>(
      args?: Subset<T, motosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MotosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Motos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MotosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MotosAggregateArgs>(args: Subset<T, MotosAggregateArgs>): Prisma.PrismaPromise<GetMotosAggregateType<T>>

    /**
     * Group by Motos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {motosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends motosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: motosGroupByArgs['orderBy'] }
        : { orderBy?: motosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, motosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMotosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the motos model
   */
  readonly fields: motosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for motos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__motosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the motos model
   */ 
  interface motosFieldRefs {
    readonly IdMoto: FieldRef<"motos", 'Int'>
    readonly NomMoto: FieldRef<"motos", 'String'>
    readonly Constructeur: FieldRef<"motos", 'String'>
    readonly Modele: FieldRef<"motos", 'String'>
    readonly DescriptionDuProduit: FieldRef<"motos", 'String'>
    readonly Prix: FieldRef<"motos", 'Decimal'>
    readonly Stock: FieldRef<"motos", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * motos findUnique
   */
  export type motosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the motos
     */
    select?: motosSelect<ExtArgs> | null
    /**
     * Filter, which motos to fetch.
     */
    where: motosWhereUniqueInput
  }


  /**
   * motos findUniqueOrThrow
   */
  export type motosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the motos
     */
    select?: motosSelect<ExtArgs> | null
    /**
     * Filter, which motos to fetch.
     */
    where: motosWhereUniqueInput
  }


  /**
   * motos findFirst
   */
  export type motosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the motos
     */
    select?: motosSelect<ExtArgs> | null
    /**
     * Filter, which motos to fetch.
     */
    where?: motosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of motos to fetch.
     */
    orderBy?: motosOrderByWithRelationInput | motosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for motos.
     */
    cursor?: motosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` motos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` motos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of motos.
     */
    distinct?: MotosScalarFieldEnum | MotosScalarFieldEnum[]
  }


  /**
   * motos findFirstOrThrow
   */
  export type motosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the motos
     */
    select?: motosSelect<ExtArgs> | null
    /**
     * Filter, which motos to fetch.
     */
    where?: motosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of motos to fetch.
     */
    orderBy?: motosOrderByWithRelationInput | motosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for motos.
     */
    cursor?: motosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` motos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` motos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of motos.
     */
    distinct?: MotosScalarFieldEnum | MotosScalarFieldEnum[]
  }


  /**
   * motos findMany
   */
  export type motosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the motos
     */
    select?: motosSelect<ExtArgs> | null
    /**
     * Filter, which motos to fetch.
     */
    where?: motosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of motos to fetch.
     */
    orderBy?: motosOrderByWithRelationInput | motosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing motos.
     */
    cursor?: motosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` motos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` motos.
     */
    skip?: number
    distinct?: MotosScalarFieldEnum | MotosScalarFieldEnum[]
  }


  /**
   * motos create
   */
  export type motosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the motos
     */
    select?: motosSelect<ExtArgs> | null
    /**
     * The data needed to create a motos.
     */
    data: XOR<motosCreateInput, motosUncheckedCreateInput>
  }


  /**
   * motos createMany
   */
  export type motosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many motos.
     */
    data: motosCreateManyInput | motosCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * motos update
   */
  export type motosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the motos
     */
    select?: motosSelect<ExtArgs> | null
    /**
     * The data needed to update a motos.
     */
    data: XOR<motosUpdateInput, motosUncheckedUpdateInput>
    /**
     * Choose, which motos to update.
     */
    where: motosWhereUniqueInput
  }


  /**
   * motos updateMany
   */
  export type motosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update motos.
     */
    data: XOR<motosUpdateManyMutationInput, motosUncheckedUpdateManyInput>
    /**
     * Filter which motos to update
     */
    where?: motosWhereInput
  }


  /**
   * motos upsert
   */
  export type motosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the motos
     */
    select?: motosSelect<ExtArgs> | null
    /**
     * The filter to search for the motos to update in case it exists.
     */
    where: motosWhereUniqueInput
    /**
     * In case the motos found by the `where` argument doesn't exist, create a new motos with this data.
     */
    create: XOR<motosCreateInput, motosUncheckedCreateInput>
    /**
     * In case the motos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<motosUpdateInput, motosUncheckedUpdateInput>
  }


  /**
   * motos delete
   */
  export type motosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the motos
     */
    select?: motosSelect<ExtArgs> | null
    /**
     * Filter which motos to delete.
     */
    where: motosWhereUniqueInput
  }


  /**
   * motos deleteMany
   */
  export type motosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which motos to delete
     */
    where?: motosWhereInput
  }


  /**
   * motos without action
   */
  export type motosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the motos
     */
    select?: motosSelect<ExtArgs> | null
  }



  /**
   * Model panier
   */

  export type AggregatePanier = {
    _count: PanierCountAggregateOutputType | null
    _avg: PanierAvgAggregateOutputType | null
    _sum: PanierSumAggregateOutputType | null
    _min: PanierMinAggregateOutputType | null
    _max: PanierMaxAggregateOutputType | null
  }

  export type PanierAvgAggregateOutputType = {
    IdPanier: number | null
    Quantite: number | null
    IdClient: number | null
  }

  export type PanierSumAggregateOutputType = {
    IdPanier: number | null
    Quantite: bigint | null
    IdClient: number | null
  }

  export type PanierMinAggregateOutputType = {
    IdPanier: number | null
    Quantite: bigint | null
    IdClient: number | null
  }

  export type PanierMaxAggregateOutputType = {
    IdPanier: number | null
    Quantite: bigint | null
    IdClient: number | null
  }

  export type PanierCountAggregateOutputType = {
    IdPanier: number
    Quantite: number
    IdClient: number
    _all: number
  }


  export type PanierAvgAggregateInputType = {
    IdPanier?: true
    Quantite?: true
    IdClient?: true
  }

  export type PanierSumAggregateInputType = {
    IdPanier?: true
    Quantite?: true
    IdClient?: true
  }

  export type PanierMinAggregateInputType = {
    IdPanier?: true
    Quantite?: true
    IdClient?: true
  }

  export type PanierMaxAggregateInputType = {
    IdPanier?: true
    Quantite?: true
    IdClient?: true
  }

  export type PanierCountAggregateInputType = {
    IdPanier?: true
    Quantite?: true
    IdClient?: true
    _all?: true
  }

  export type PanierAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which panier to aggregate.
     */
    where?: panierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of paniers to fetch.
     */
    orderBy?: panierOrderByWithRelationInput | panierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: panierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` paniers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` paniers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned paniers
    **/
    _count?: true | PanierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PanierAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PanierSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PanierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PanierMaxAggregateInputType
  }

  export type GetPanierAggregateType<T extends PanierAggregateArgs> = {
        [P in keyof T & keyof AggregatePanier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePanier[P]>
      : GetScalarType<T[P], AggregatePanier[P]>
  }




  export type panierGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: panierWhereInput
    orderBy?: panierOrderByWithAggregationInput | panierOrderByWithAggregationInput[]
    by: PanierScalarFieldEnum[] | PanierScalarFieldEnum
    having?: panierScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PanierCountAggregateInputType | true
    _avg?: PanierAvgAggregateInputType
    _sum?: PanierSumAggregateInputType
    _min?: PanierMinAggregateInputType
    _max?: PanierMaxAggregateInputType
  }

  export type PanierGroupByOutputType = {
    IdPanier: number
    Quantite: bigint
    IdClient: number
    _count: PanierCountAggregateOutputType | null
    _avg: PanierAvgAggregateOutputType | null
    _sum: PanierSumAggregateOutputType | null
    _min: PanierMinAggregateOutputType | null
    _max: PanierMaxAggregateOutputType | null
  }

  type GetPanierGroupByPayload<T extends panierGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PanierGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PanierGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PanierGroupByOutputType[P]>
            : GetScalarType<T[P], PanierGroupByOutputType[P]>
        }
      >
    >


  export type panierSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdPanier?: boolean
    Quantite?: boolean
    IdClient?: boolean
  }, ExtArgs["result"]["panier"]>

  export type panierSelectScalar = {
    IdPanier?: boolean
    Quantite?: boolean
    IdClient?: boolean
  }


  export type $panierPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "panier"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      IdPanier: number
      Quantite: bigint
      IdClient: number
    }, ExtArgs["result"]["panier"]>
    composites: {}
  }


  type panierGetPayload<S extends boolean | null | undefined | panierDefaultArgs> = $Result.GetResult<Prisma.$panierPayload, S>

  type panierCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<panierFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PanierCountAggregateInputType | true
    }

  export interface panierDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['panier'], meta: { name: 'panier' } }
    /**
     * Find zero or one Panier that matches the filter.
     * @param {panierFindUniqueArgs} args - Arguments to find a Panier
     * @example
     * // Get one Panier
     * const panier = await prisma.panier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends panierFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, panierFindUniqueArgs<ExtArgs>>
    ): Prisma__panierClient<$Result.GetResult<Prisma.$panierPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Panier that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {panierFindUniqueOrThrowArgs} args - Arguments to find a Panier
     * @example
     * // Get one Panier
     * const panier = await prisma.panier.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends panierFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, panierFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__panierClient<$Result.GetResult<Prisma.$panierPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Panier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {panierFindFirstArgs} args - Arguments to find a Panier
     * @example
     * // Get one Panier
     * const panier = await prisma.panier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends panierFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, panierFindFirstArgs<ExtArgs>>
    ): Prisma__panierClient<$Result.GetResult<Prisma.$panierPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Panier that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {panierFindFirstOrThrowArgs} args - Arguments to find a Panier
     * @example
     * // Get one Panier
     * const panier = await prisma.panier.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends panierFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, panierFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__panierClient<$Result.GetResult<Prisma.$panierPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Paniers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {panierFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Paniers
     * const paniers = await prisma.panier.findMany()
     * 
     * // Get first 10 Paniers
     * const paniers = await prisma.panier.findMany({ take: 10 })
     * 
     * // Only select the `IdPanier`
     * const panierWithIdPanierOnly = await prisma.panier.findMany({ select: { IdPanier: true } })
     * 
    **/
    findMany<T extends panierFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, panierFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$panierPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Panier.
     * @param {panierCreateArgs} args - Arguments to create a Panier.
     * @example
     * // Create one Panier
     * const Panier = await prisma.panier.create({
     *   data: {
     *     // ... data to create a Panier
     *   }
     * })
     * 
    **/
    create<T extends panierCreateArgs<ExtArgs>>(
      args: SelectSubset<T, panierCreateArgs<ExtArgs>>
    ): Prisma__panierClient<$Result.GetResult<Prisma.$panierPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Paniers.
     *     @param {panierCreateManyArgs} args - Arguments to create many Paniers.
     *     @example
     *     // Create many Paniers
     *     const panier = await prisma.panier.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends panierCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, panierCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Panier.
     * @param {panierDeleteArgs} args - Arguments to delete one Panier.
     * @example
     * // Delete one Panier
     * const Panier = await prisma.panier.delete({
     *   where: {
     *     // ... filter to delete one Panier
     *   }
     * })
     * 
    **/
    delete<T extends panierDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, panierDeleteArgs<ExtArgs>>
    ): Prisma__panierClient<$Result.GetResult<Prisma.$panierPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Panier.
     * @param {panierUpdateArgs} args - Arguments to update one Panier.
     * @example
     * // Update one Panier
     * const panier = await prisma.panier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends panierUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, panierUpdateArgs<ExtArgs>>
    ): Prisma__panierClient<$Result.GetResult<Prisma.$panierPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Paniers.
     * @param {panierDeleteManyArgs} args - Arguments to filter Paniers to delete.
     * @example
     * // Delete a few Paniers
     * const { count } = await prisma.panier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends panierDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, panierDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Paniers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {panierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Paniers
     * const panier = await prisma.panier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends panierUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, panierUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Panier.
     * @param {panierUpsertArgs} args - Arguments to update or create a Panier.
     * @example
     * // Update or create a Panier
     * const panier = await prisma.panier.upsert({
     *   create: {
     *     // ... data to create a Panier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Panier we want to update
     *   }
     * })
    **/
    upsert<T extends panierUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, panierUpsertArgs<ExtArgs>>
    ): Prisma__panierClient<$Result.GetResult<Prisma.$panierPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Paniers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {panierCountArgs} args - Arguments to filter Paniers to count.
     * @example
     * // Count the number of Paniers
     * const count = await prisma.panier.count({
     *   where: {
     *     // ... the filter for the Paniers we want to count
     *   }
     * })
    **/
    count<T extends panierCountArgs>(
      args?: Subset<T, panierCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PanierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Panier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PanierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PanierAggregateArgs>(args: Subset<T, PanierAggregateArgs>): Prisma.PrismaPromise<GetPanierAggregateType<T>>

    /**
     * Group by Panier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {panierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends panierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: panierGroupByArgs['orderBy'] }
        : { orderBy?: panierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, panierGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPanierGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the panier model
   */
  readonly fields: panierFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for panier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__panierClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the panier model
   */ 
  interface panierFieldRefs {
    readonly IdPanier: FieldRef<"panier", 'Int'>
    readonly Quantite: FieldRef<"panier", 'BigInt'>
    readonly IdClient: FieldRef<"panier", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * panier findUnique
   */
  export type panierFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the panier
     */
    select?: panierSelect<ExtArgs> | null
    /**
     * Filter, which panier to fetch.
     */
    where: panierWhereUniqueInput
  }


  /**
   * panier findUniqueOrThrow
   */
  export type panierFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the panier
     */
    select?: panierSelect<ExtArgs> | null
    /**
     * Filter, which panier to fetch.
     */
    where: panierWhereUniqueInput
  }


  /**
   * panier findFirst
   */
  export type panierFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the panier
     */
    select?: panierSelect<ExtArgs> | null
    /**
     * Filter, which panier to fetch.
     */
    where?: panierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of paniers to fetch.
     */
    orderBy?: panierOrderByWithRelationInput | panierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for paniers.
     */
    cursor?: panierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` paniers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` paniers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of paniers.
     */
    distinct?: PanierScalarFieldEnum | PanierScalarFieldEnum[]
  }


  /**
   * panier findFirstOrThrow
   */
  export type panierFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the panier
     */
    select?: panierSelect<ExtArgs> | null
    /**
     * Filter, which panier to fetch.
     */
    where?: panierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of paniers to fetch.
     */
    orderBy?: panierOrderByWithRelationInput | panierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for paniers.
     */
    cursor?: panierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` paniers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` paniers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of paniers.
     */
    distinct?: PanierScalarFieldEnum | PanierScalarFieldEnum[]
  }


  /**
   * panier findMany
   */
  export type panierFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the panier
     */
    select?: panierSelect<ExtArgs> | null
    /**
     * Filter, which paniers to fetch.
     */
    where?: panierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of paniers to fetch.
     */
    orderBy?: panierOrderByWithRelationInput | panierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing paniers.
     */
    cursor?: panierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` paniers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` paniers.
     */
    skip?: number
    distinct?: PanierScalarFieldEnum | PanierScalarFieldEnum[]
  }


  /**
   * panier create
   */
  export type panierCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the panier
     */
    select?: panierSelect<ExtArgs> | null
    /**
     * The data needed to create a panier.
     */
    data: XOR<panierCreateInput, panierUncheckedCreateInput>
  }


  /**
   * panier createMany
   */
  export type panierCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many paniers.
     */
    data: panierCreateManyInput | panierCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * panier update
   */
  export type panierUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the panier
     */
    select?: panierSelect<ExtArgs> | null
    /**
     * The data needed to update a panier.
     */
    data: XOR<panierUpdateInput, panierUncheckedUpdateInput>
    /**
     * Choose, which panier to update.
     */
    where: panierWhereUniqueInput
  }


  /**
   * panier updateMany
   */
  export type panierUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update paniers.
     */
    data: XOR<panierUpdateManyMutationInput, panierUncheckedUpdateManyInput>
    /**
     * Filter which paniers to update
     */
    where?: panierWhereInput
  }


  /**
   * panier upsert
   */
  export type panierUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the panier
     */
    select?: panierSelect<ExtArgs> | null
    /**
     * The filter to search for the panier to update in case it exists.
     */
    where: panierWhereUniqueInput
    /**
     * In case the panier found by the `where` argument doesn't exist, create a new panier with this data.
     */
    create: XOR<panierCreateInput, panierUncheckedCreateInput>
    /**
     * In case the panier was found with the provided `where` argument, update it with this data.
     */
    update: XOR<panierUpdateInput, panierUncheckedUpdateInput>
  }


  /**
   * panier delete
   */
  export type panierDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the panier
     */
    select?: panierSelect<ExtArgs> | null
    /**
     * Filter which panier to delete.
     */
    where: panierWhereUniqueInput
  }


  /**
   * panier deleteMany
   */
  export type panierDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which paniers to delete
     */
    where?: panierWhereInput
  }


  /**
   * panier without action
   */
  export type panierDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the panier
     */
    select?: panierSelect<ExtArgs> | null
  }



  /**
   * Model utilise
   */

  export type AggregateUtilise = {
    _count: UtiliseCountAggregateOutputType | null
    _avg: UtiliseAvgAggregateOutputType | null
    _sum: UtiliseSumAggregateOutputType | null
    _min: UtiliseMinAggregateOutputType | null
    _max: UtiliseMaxAggregateOutputType | null
  }

  export type UtiliseAvgAggregateOutputType = {
    IdPaiement: number | null
    IdClient: number | null
  }

  export type UtiliseSumAggregateOutputType = {
    IdPaiement: number | null
    IdClient: number | null
  }

  export type UtiliseMinAggregateOutputType = {
    IdPaiement: number | null
    IdClient: number | null
  }

  export type UtiliseMaxAggregateOutputType = {
    IdPaiement: number | null
    IdClient: number | null
  }

  export type UtiliseCountAggregateOutputType = {
    IdPaiement: number
    IdClient: number
    _all: number
  }


  export type UtiliseAvgAggregateInputType = {
    IdPaiement?: true
    IdClient?: true
  }

  export type UtiliseSumAggregateInputType = {
    IdPaiement?: true
    IdClient?: true
  }

  export type UtiliseMinAggregateInputType = {
    IdPaiement?: true
    IdClient?: true
  }

  export type UtiliseMaxAggregateInputType = {
    IdPaiement?: true
    IdClient?: true
  }

  export type UtiliseCountAggregateInputType = {
    IdPaiement?: true
    IdClient?: true
    _all?: true
  }

  export type UtiliseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which utilise to aggregate.
     */
    where?: utiliseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of utilises to fetch.
     */
    orderBy?: utiliseOrderByWithRelationInput | utiliseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: utiliseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` utilises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` utilises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned utilises
    **/
    _count?: true | UtiliseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UtiliseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UtiliseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UtiliseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UtiliseMaxAggregateInputType
  }

  export type GetUtiliseAggregateType<T extends UtiliseAggregateArgs> = {
        [P in keyof T & keyof AggregateUtilise]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUtilise[P]>
      : GetScalarType<T[P], AggregateUtilise[P]>
  }




  export type utiliseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: utiliseWhereInput
    orderBy?: utiliseOrderByWithAggregationInput | utiliseOrderByWithAggregationInput[]
    by: UtiliseScalarFieldEnum[] | UtiliseScalarFieldEnum
    having?: utiliseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UtiliseCountAggregateInputType | true
    _avg?: UtiliseAvgAggregateInputType
    _sum?: UtiliseSumAggregateInputType
    _min?: UtiliseMinAggregateInputType
    _max?: UtiliseMaxAggregateInputType
  }

  export type UtiliseGroupByOutputType = {
    IdPaiement: number
    IdClient: number
    _count: UtiliseCountAggregateOutputType | null
    _avg: UtiliseAvgAggregateOutputType | null
    _sum: UtiliseSumAggregateOutputType | null
    _min: UtiliseMinAggregateOutputType | null
    _max: UtiliseMaxAggregateOutputType | null
  }

  type GetUtiliseGroupByPayload<T extends utiliseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UtiliseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UtiliseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UtiliseGroupByOutputType[P]>
            : GetScalarType<T[P], UtiliseGroupByOutputType[P]>
        }
      >
    >


  export type utiliseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdPaiement?: boolean
    IdClient?: boolean
  }, ExtArgs["result"]["utilise"]>

  export type utiliseSelectScalar = {
    IdPaiement?: boolean
    IdClient?: boolean
  }


  export type $utilisePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "utilise"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      IdPaiement: number
      IdClient: number
    }, ExtArgs["result"]["utilise"]>
    composites: {}
  }


  type utiliseGetPayload<S extends boolean | null | undefined | utiliseDefaultArgs> = $Result.GetResult<Prisma.$utilisePayload, S>

  type utiliseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<utiliseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UtiliseCountAggregateInputType | true
    }

  export interface utiliseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['utilise'], meta: { name: 'utilise' } }
    /**
     * Find zero or one Utilise that matches the filter.
     * @param {utiliseFindUniqueArgs} args - Arguments to find a Utilise
     * @example
     * // Get one Utilise
     * const utilise = await prisma.utilise.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends utiliseFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, utiliseFindUniqueArgs<ExtArgs>>
    ): Prisma__utiliseClient<$Result.GetResult<Prisma.$utilisePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Utilise that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {utiliseFindUniqueOrThrowArgs} args - Arguments to find a Utilise
     * @example
     * // Get one Utilise
     * const utilise = await prisma.utilise.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends utiliseFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, utiliseFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__utiliseClient<$Result.GetResult<Prisma.$utilisePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Utilise that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {utiliseFindFirstArgs} args - Arguments to find a Utilise
     * @example
     * // Get one Utilise
     * const utilise = await prisma.utilise.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends utiliseFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, utiliseFindFirstArgs<ExtArgs>>
    ): Prisma__utiliseClient<$Result.GetResult<Prisma.$utilisePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Utilise that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {utiliseFindFirstOrThrowArgs} args - Arguments to find a Utilise
     * @example
     * // Get one Utilise
     * const utilise = await prisma.utilise.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends utiliseFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, utiliseFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__utiliseClient<$Result.GetResult<Prisma.$utilisePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Utilises that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {utiliseFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Utilises
     * const utilises = await prisma.utilise.findMany()
     * 
     * // Get first 10 Utilises
     * const utilises = await prisma.utilise.findMany({ take: 10 })
     * 
     * // Only select the `IdPaiement`
     * const utiliseWithIdPaiementOnly = await prisma.utilise.findMany({ select: { IdPaiement: true } })
     * 
    **/
    findMany<T extends utiliseFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, utiliseFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$utilisePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Utilise.
     * @param {utiliseCreateArgs} args - Arguments to create a Utilise.
     * @example
     * // Create one Utilise
     * const Utilise = await prisma.utilise.create({
     *   data: {
     *     // ... data to create a Utilise
     *   }
     * })
     * 
    **/
    create<T extends utiliseCreateArgs<ExtArgs>>(
      args: SelectSubset<T, utiliseCreateArgs<ExtArgs>>
    ): Prisma__utiliseClient<$Result.GetResult<Prisma.$utilisePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Utilises.
     *     @param {utiliseCreateManyArgs} args - Arguments to create many Utilises.
     *     @example
     *     // Create many Utilises
     *     const utilise = await prisma.utilise.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends utiliseCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, utiliseCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Utilise.
     * @param {utiliseDeleteArgs} args - Arguments to delete one Utilise.
     * @example
     * // Delete one Utilise
     * const Utilise = await prisma.utilise.delete({
     *   where: {
     *     // ... filter to delete one Utilise
     *   }
     * })
     * 
    **/
    delete<T extends utiliseDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, utiliseDeleteArgs<ExtArgs>>
    ): Prisma__utiliseClient<$Result.GetResult<Prisma.$utilisePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Utilise.
     * @param {utiliseUpdateArgs} args - Arguments to update one Utilise.
     * @example
     * // Update one Utilise
     * const utilise = await prisma.utilise.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends utiliseUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, utiliseUpdateArgs<ExtArgs>>
    ): Prisma__utiliseClient<$Result.GetResult<Prisma.$utilisePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Utilises.
     * @param {utiliseDeleteManyArgs} args - Arguments to filter Utilises to delete.
     * @example
     * // Delete a few Utilises
     * const { count } = await prisma.utilise.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends utiliseDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, utiliseDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Utilises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {utiliseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Utilises
     * const utilise = await prisma.utilise.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends utiliseUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, utiliseUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Utilise.
     * @param {utiliseUpsertArgs} args - Arguments to update or create a Utilise.
     * @example
     * // Update or create a Utilise
     * const utilise = await prisma.utilise.upsert({
     *   create: {
     *     // ... data to create a Utilise
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Utilise we want to update
     *   }
     * })
    **/
    upsert<T extends utiliseUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, utiliseUpsertArgs<ExtArgs>>
    ): Prisma__utiliseClient<$Result.GetResult<Prisma.$utilisePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Utilises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {utiliseCountArgs} args - Arguments to filter Utilises to count.
     * @example
     * // Count the number of Utilises
     * const count = await prisma.utilise.count({
     *   where: {
     *     // ... the filter for the Utilises we want to count
     *   }
     * })
    **/
    count<T extends utiliseCountArgs>(
      args?: Subset<T, utiliseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UtiliseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Utilise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UtiliseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UtiliseAggregateArgs>(args: Subset<T, UtiliseAggregateArgs>): Prisma.PrismaPromise<GetUtiliseAggregateType<T>>

    /**
     * Group by Utilise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {utiliseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends utiliseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: utiliseGroupByArgs['orderBy'] }
        : { orderBy?: utiliseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, utiliseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUtiliseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the utilise model
   */
  readonly fields: utiliseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for utilise.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__utiliseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the utilise model
   */ 
  interface utiliseFieldRefs {
    readonly IdPaiement: FieldRef<"utilise", 'Int'>
    readonly IdClient: FieldRef<"utilise", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * utilise findUnique
   */
  export type utiliseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the utilise
     */
    select?: utiliseSelect<ExtArgs> | null
    /**
     * Filter, which utilise to fetch.
     */
    where: utiliseWhereUniqueInput
  }


  /**
   * utilise findUniqueOrThrow
   */
  export type utiliseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the utilise
     */
    select?: utiliseSelect<ExtArgs> | null
    /**
     * Filter, which utilise to fetch.
     */
    where: utiliseWhereUniqueInput
  }


  /**
   * utilise findFirst
   */
  export type utiliseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the utilise
     */
    select?: utiliseSelect<ExtArgs> | null
    /**
     * Filter, which utilise to fetch.
     */
    where?: utiliseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of utilises to fetch.
     */
    orderBy?: utiliseOrderByWithRelationInput | utiliseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for utilises.
     */
    cursor?: utiliseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` utilises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` utilises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of utilises.
     */
    distinct?: UtiliseScalarFieldEnum | UtiliseScalarFieldEnum[]
  }


  /**
   * utilise findFirstOrThrow
   */
  export type utiliseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the utilise
     */
    select?: utiliseSelect<ExtArgs> | null
    /**
     * Filter, which utilise to fetch.
     */
    where?: utiliseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of utilises to fetch.
     */
    orderBy?: utiliseOrderByWithRelationInput | utiliseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for utilises.
     */
    cursor?: utiliseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` utilises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` utilises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of utilises.
     */
    distinct?: UtiliseScalarFieldEnum | UtiliseScalarFieldEnum[]
  }


  /**
   * utilise findMany
   */
  export type utiliseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the utilise
     */
    select?: utiliseSelect<ExtArgs> | null
    /**
     * Filter, which utilises to fetch.
     */
    where?: utiliseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of utilises to fetch.
     */
    orderBy?: utiliseOrderByWithRelationInput | utiliseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing utilises.
     */
    cursor?: utiliseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` utilises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` utilises.
     */
    skip?: number
    distinct?: UtiliseScalarFieldEnum | UtiliseScalarFieldEnum[]
  }


  /**
   * utilise create
   */
  export type utiliseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the utilise
     */
    select?: utiliseSelect<ExtArgs> | null
    /**
     * The data needed to create a utilise.
     */
    data: XOR<utiliseCreateInput, utiliseUncheckedCreateInput>
  }


  /**
   * utilise createMany
   */
  export type utiliseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many utilises.
     */
    data: utiliseCreateManyInput | utiliseCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * utilise update
   */
  export type utiliseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the utilise
     */
    select?: utiliseSelect<ExtArgs> | null
    /**
     * The data needed to update a utilise.
     */
    data: XOR<utiliseUpdateInput, utiliseUncheckedUpdateInput>
    /**
     * Choose, which utilise to update.
     */
    where: utiliseWhereUniqueInput
  }


  /**
   * utilise updateMany
   */
  export type utiliseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update utilises.
     */
    data: XOR<utiliseUpdateManyMutationInput, utiliseUncheckedUpdateManyInput>
    /**
     * Filter which utilises to update
     */
    where?: utiliseWhereInput
  }


  /**
   * utilise upsert
   */
  export type utiliseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the utilise
     */
    select?: utiliseSelect<ExtArgs> | null
    /**
     * The filter to search for the utilise to update in case it exists.
     */
    where: utiliseWhereUniqueInput
    /**
     * In case the utilise found by the `where` argument doesn't exist, create a new utilise with this data.
     */
    create: XOR<utiliseCreateInput, utiliseUncheckedCreateInput>
    /**
     * In case the utilise was found with the provided `where` argument, update it with this data.
     */
    update: XOR<utiliseUpdateInput, utiliseUncheckedUpdateInput>
  }


  /**
   * utilise delete
   */
  export type utiliseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the utilise
     */
    select?: utiliseSelect<ExtArgs> | null
    /**
     * Filter which utilise to delete.
     */
    where: utiliseWhereUniqueInput
  }


  /**
   * utilise deleteMany
   */
  export type utiliseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which utilises to delete
     */
    where?: utiliseWhereInput
  }


  /**
   * utilise without action
   */
  export type utiliseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the utilise
     */
    select?: utiliseSelect<ExtArgs> | null
  }



  /**
   * Model motossurcommande
   */

  export type AggregateMotossurcommande = {
    _count: MotossurcommandeCountAggregateOutputType | null
    _avg: MotossurcommandeAvgAggregateOutputType | null
    _sum: MotossurcommandeSumAggregateOutputType | null
    _min: MotossurcommandeMinAggregateOutputType | null
    _max: MotossurcommandeMaxAggregateOutputType | null
  }

  export type MotossurcommandeAvgAggregateOutputType = {
    commandeId: number | null
    motoId: number | null
  }

  export type MotossurcommandeSumAggregateOutputType = {
    commandeId: number | null
    motoId: number | null
  }

  export type MotossurcommandeMinAggregateOutputType = {
    commandeId: number | null
    motoId: number | null
  }

  export type MotossurcommandeMaxAggregateOutputType = {
    commandeId: number | null
    motoId: number | null
  }

  export type MotossurcommandeCountAggregateOutputType = {
    commandeId: number
    motoId: number
    _all: number
  }


  export type MotossurcommandeAvgAggregateInputType = {
    commandeId?: true
    motoId?: true
  }

  export type MotossurcommandeSumAggregateInputType = {
    commandeId?: true
    motoId?: true
  }

  export type MotossurcommandeMinAggregateInputType = {
    commandeId?: true
    motoId?: true
  }

  export type MotossurcommandeMaxAggregateInputType = {
    commandeId?: true
    motoId?: true
  }

  export type MotossurcommandeCountAggregateInputType = {
    commandeId?: true
    motoId?: true
    _all?: true
  }

  export type MotossurcommandeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which motossurcommande to aggregate.
     */
    where?: motossurcommandeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of motossurcommandes to fetch.
     */
    orderBy?: motossurcommandeOrderByWithRelationInput | motossurcommandeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: motossurcommandeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` motossurcommandes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` motossurcommandes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned motossurcommandes
    **/
    _count?: true | MotossurcommandeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MotossurcommandeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MotossurcommandeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MotossurcommandeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MotossurcommandeMaxAggregateInputType
  }

  export type GetMotossurcommandeAggregateType<T extends MotossurcommandeAggregateArgs> = {
        [P in keyof T & keyof AggregateMotossurcommande]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMotossurcommande[P]>
      : GetScalarType<T[P], AggregateMotossurcommande[P]>
  }




  export type motossurcommandeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: motossurcommandeWhereInput
    orderBy?: motossurcommandeOrderByWithAggregationInput | motossurcommandeOrderByWithAggregationInput[]
    by: MotossurcommandeScalarFieldEnum[] | MotossurcommandeScalarFieldEnum
    having?: motossurcommandeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MotossurcommandeCountAggregateInputType | true
    _avg?: MotossurcommandeAvgAggregateInputType
    _sum?: MotossurcommandeSumAggregateInputType
    _min?: MotossurcommandeMinAggregateInputType
    _max?: MotossurcommandeMaxAggregateInputType
  }

  export type MotossurcommandeGroupByOutputType = {
    commandeId: number
    motoId: number
    _count: MotossurcommandeCountAggregateOutputType | null
    _avg: MotossurcommandeAvgAggregateOutputType | null
    _sum: MotossurcommandeSumAggregateOutputType | null
    _min: MotossurcommandeMinAggregateOutputType | null
    _max: MotossurcommandeMaxAggregateOutputType | null
  }

  type GetMotossurcommandeGroupByPayload<T extends motossurcommandeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MotossurcommandeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MotossurcommandeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MotossurcommandeGroupByOutputType[P]>
            : GetScalarType<T[P], MotossurcommandeGroupByOutputType[P]>
        }
      >
    >


  export type motossurcommandeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    commandeId?: boolean
    motoId?: boolean
  }, ExtArgs["result"]["motossurcommande"]>

  export type motossurcommandeSelectScalar = {
    commandeId?: boolean
    motoId?: boolean
  }


  export type $motossurcommandePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "motossurcommande"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      commandeId: number
      motoId: number
    }, ExtArgs["result"]["motossurcommande"]>
    composites: {}
  }


  type motossurcommandeGetPayload<S extends boolean | null | undefined | motossurcommandeDefaultArgs> = $Result.GetResult<Prisma.$motossurcommandePayload, S>

  type motossurcommandeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<motossurcommandeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MotossurcommandeCountAggregateInputType | true
    }

  export interface motossurcommandeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['motossurcommande'], meta: { name: 'motossurcommande' } }
    /**
     * Find zero or one Motossurcommande that matches the filter.
     * @param {motossurcommandeFindUniqueArgs} args - Arguments to find a Motossurcommande
     * @example
     * // Get one Motossurcommande
     * const motossurcommande = await prisma.motossurcommande.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends motossurcommandeFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, motossurcommandeFindUniqueArgs<ExtArgs>>
    ): Prisma__motossurcommandeClient<$Result.GetResult<Prisma.$motossurcommandePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Motossurcommande that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {motossurcommandeFindUniqueOrThrowArgs} args - Arguments to find a Motossurcommande
     * @example
     * // Get one Motossurcommande
     * const motossurcommande = await prisma.motossurcommande.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends motossurcommandeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, motossurcommandeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__motossurcommandeClient<$Result.GetResult<Prisma.$motossurcommandePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Motossurcommande that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {motossurcommandeFindFirstArgs} args - Arguments to find a Motossurcommande
     * @example
     * // Get one Motossurcommande
     * const motossurcommande = await prisma.motossurcommande.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends motossurcommandeFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, motossurcommandeFindFirstArgs<ExtArgs>>
    ): Prisma__motossurcommandeClient<$Result.GetResult<Prisma.$motossurcommandePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Motossurcommande that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {motossurcommandeFindFirstOrThrowArgs} args - Arguments to find a Motossurcommande
     * @example
     * // Get one Motossurcommande
     * const motossurcommande = await prisma.motossurcommande.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends motossurcommandeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, motossurcommandeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__motossurcommandeClient<$Result.GetResult<Prisma.$motossurcommandePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Motossurcommandes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {motossurcommandeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Motossurcommandes
     * const motossurcommandes = await prisma.motossurcommande.findMany()
     * 
     * // Get first 10 Motossurcommandes
     * const motossurcommandes = await prisma.motossurcommande.findMany({ take: 10 })
     * 
     * // Only select the `commandeId`
     * const motossurcommandeWithCommandeIdOnly = await prisma.motossurcommande.findMany({ select: { commandeId: true } })
     * 
    **/
    findMany<T extends motossurcommandeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, motossurcommandeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$motossurcommandePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Motossurcommande.
     * @param {motossurcommandeCreateArgs} args - Arguments to create a Motossurcommande.
     * @example
     * // Create one Motossurcommande
     * const Motossurcommande = await prisma.motossurcommande.create({
     *   data: {
     *     // ... data to create a Motossurcommande
     *   }
     * })
     * 
    **/
    create<T extends motossurcommandeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, motossurcommandeCreateArgs<ExtArgs>>
    ): Prisma__motossurcommandeClient<$Result.GetResult<Prisma.$motossurcommandePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Motossurcommandes.
     *     @param {motossurcommandeCreateManyArgs} args - Arguments to create many Motossurcommandes.
     *     @example
     *     // Create many Motossurcommandes
     *     const motossurcommande = await prisma.motossurcommande.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends motossurcommandeCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, motossurcommandeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Motossurcommande.
     * @param {motossurcommandeDeleteArgs} args - Arguments to delete one Motossurcommande.
     * @example
     * // Delete one Motossurcommande
     * const Motossurcommande = await prisma.motossurcommande.delete({
     *   where: {
     *     // ... filter to delete one Motossurcommande
     *   }
     * })
     * 
    **/
    delete<T extends motossurcommandeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, motossurcommandeDeleteArgs<ExtArgs>>
    ): Prisma__motossurcommandeClient<$Result.GetResult<Prisma.$motossurcommandePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Motossurcommande.
     * @param {motossurcommandeUpdateArgs} args - Arguments to update one Motossurcommande.
     * @example
     * // Update one Motossurcommande
     * const motossurcommande = await prisma.motossurcommande.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends motossurcommandeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, motossurcommandeUpdateArgs<ExtArgs>>
    ): Prisma__motossurcommandeClient<$Result.GetResult<Prisma.$motossurcommandePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Motossurcommandes.
     * @param {motossurcommandeDeleteManyArgs} args - Arguments to filter Motossurcommandes to delete.
     * @example
     * // Delete a few Motossurcommandes
     * const { count } = await prisma.motossurcommande.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends motossurcommandeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, motossurcommandeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Motossurcommandes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {motossurcommandeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Motossurcommandes
     * const motossurcommande = await prisma.motossurcommande.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends motossurcommandeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, motossurcommandeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Motossurcommande.
     * @param {motossurcommandeUpsertArgs} args - Arguments to update or create a Motossurcommande.
     * @example
     * // Update or create a Motossurcommande
     * const motossurcommande = await prisma.motossurcommande.upsert({
     *   create: {
     *     // ... data to create a Motossurcommande
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Motossurcommande we want to update
     *   }
     * })
    **/
    upsert<T extends motossurcommandeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, motossurcommandeUpsertArgs<ExtArgs>>
    ): Prisma__motossurcommandeClient<$Result.GetResult<Prisma.$motossurcommandePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Motossurcommandes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {motossurcommandeCountArgs} args - Arguments to filter Motossurcommandes to count.
     * @example
     * // Count the number of Motossurcommandes
     * const count = await prisma.motossurcommande.count({
     *   where: {
     *     // ... the filter for the Motossurcommandes we want to count
     *   }
     * })
    **/
    count<T extends motossurcommandeCountArgs>(
      args?: Subset<T, motossurcommandeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MotossurcommandeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Motossurcommande.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MotossurcommandeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MotossurcommandeAggregateArgs>(args: Subset<T, MotossurcommandeAggregateArgs>): Prisma.PrismaPromise<GetMotossurcommandeAggregateType<T>>

    /**
     * Group by Motossurcommande.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {motossurcommandeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends motossurcommandeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: motossurcommandeGroupByArgs['orderBy'] }
        : { orderBy?: motossurcommandeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, motossurcommandeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMotossurcommandeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the motossurcommande model
   */
  readonly fields: motossurcommandeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for motossurcommande.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__motossurcommandeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the motossurcommande model
   */ 
  interface motossurcommandeFieldRefs {
    readonly commandeId: FieldRef<"motossurcommande", 'Int'>
    readonly motoId: FieldRef<"motossurcommande", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * motossurcommande findUnique
   */
  export type motossurcommandeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the motossurcommande
     */
    select?: motossurcommandeSelect<ExtArgs> | null
    /**
     * Filter, which motossurcommande to fetch.
     */
    where: motossurcommandeWhereUniqueInput
  }


  /**
   * motossurcommande findUniqueOrThrow
   */
  export type motossurcommandeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the motossurcommande
     */
    select?: motossurcommandeSelect<ExtArgs> | null
    /**
     * Filter, which motossurcommande to fetch.
     */
    where: motossurcommandeWhereUniqueInput
  }


  /**
   * motossurcommande findFirst
   */
  export type motossurcommandeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the motossurcommande
     */
    select?: motossurcommandeSelect<ExtArgs> | null
    /**
     * Filter, which motossurcommande to fetch.
     */
    where?: motossurcommandeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of motossurcommandes to fetch.
     */
    orderBy?: motossurcommandeOrderByWithRelationInput | motossurcommandeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for motossurcommandes.
     */
    cursor?: motossurcommandeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` motossurcommandes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` motossurcommandes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of motossurcommandes.
     */
    distinct?: MotossurcommandeScalarFieldEnum | MotossurcommandeScalarFieldEnum[]
  }


  /**
   * motossurcommande findFirstOrThrow
   */
  export type motossurcommandeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the motossurcommande
     */
    select?: motossurcommandeSelect<ExtArgs> | null
    /**
     * Filter, which motossurcommande to fetch.
     */
    where?: motossurcommandeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of motossurcommandes to fetch.
     */
    orderBy?: motossurcommandeOrderByWithRelationInput | motossurcommandeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for motossurcommandes.
     */
    cursor?: motossurcommandeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` motossurcommandes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` motossurcommandes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of motossurcommandes.
     */
    distinct?: MotossurcommandeScalarFieldEnum | MotossurcommandeScalarFieldEnum[]
  }


  /**
   * motossurcommande findMany
   */
  export type motossurcommandeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the motossurcommande
     */
    select?: motossurcommandeSelect<ExtArgs> | null
    /**
     * Filter, which motossurcommandes to fetch.
     */
    where?: motossurcommandeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of motossurcommandes to fetch.
     */
    orderBy?: motossurcommandeOrderByWithRelationInput | motossurcommandeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing motossurcommandes.
     */
    cursor?: motossurcommandeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` motossurcommandes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` motossurcommandes.
     */
    skip?: number
    distinct?: MotossurcommandeScalarFieldEnum | MotossurcommandeScalarFieldEnum[]
  }


  /**
   * motossurcommande create
   */
  export type motossurcommandeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the motossurcommande
     */
    select?: motossurcommandeSelect<ExtArgs> | null
    /**
     * The data needed to create a motossurcommande.
     */
    data: XOR<motossurcommandeCreateInput, motossurcommandeUncheckedCreateInput>
  }


  /**
   * motossurcommande createMany
   */
  export type motossurcommandeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many motossurcommandes.
     */
    data: motossurcommandeCreateManyInput | motossurcommandeCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * motossurcommande update
   */
  export type motossurcommandeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the motossurcommande
     */
    select?: motossurcommandeSelect<ExtArgs> | null
    /**
     * The data needed to update a motossurcommande.
     */
    data: XOR<motossurcommandeUpdateInput, motossurcommandeUncheckedUpdateInput>
    /**
     * Choose, which motossurcommande to update.
     */
    where: motossurcommandeWhereUniqueInput
  }


  /**
   * motossurcommande updateMany
   */
  export type motossurcommandeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update motossurcommandes.
     */
    data: XOR<motossurcommandeUpdateManyMutationInput, motossurcommandeUncheckedUpdateManyInput>
    /**
     * Filter which motossurcommandes to update
     */
    where?: motossurcommandeWhereInput
  }


  /**
   * motossurcommande upsert
   */
  export type motossurcommandeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the motossurcommande
     */
    select?: motossurcommandeSelect<ExtArgs> | null
    /**
     * The filter to search for the motossurcommande to update in case it exists.
     */
    where: motossurcommandeWhereUniqueInput
    /**
     * In case the motossurcommande found by the `where` argument doesn't exist, create a new motossurcommande with this data.
     */
    create: XOR<motossurcommandeCreateInput, motossurcommandeUncheckedCreateInput>
    /**
     * In case the motossurcommande was found with the provided `where` argument, update it with this data.
     */
    update: XOR<motossurcommandeUpdateInput, motossurcommandeUncheckedUpdateInput>
  }


  /**
   * motossurcommande delete
   */
  export type motossurcommandeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the motossurcommande
     */
    select?: motossurcommandeSelect<ExtArgs> | null
    /**
     * Filter which motossurcommande to delete.
     */
    where: motossurcommandeWhereUniqueInput
  }


  /**
   * motossurcommande deleteMany
   */
  export type motossurcommandeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which motossurcommandes to delete
     */
    where?: motossurcommandeWhereInput
  }


  /**
   * motossurcommande without action
   */
  export type motossurcommandeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the motossurcommande
     */
    select?: motossurcommandeSelect<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AdresseScalarFieldEnum: {
    IdAdresse: 'IdAdresse',
    AdresseDeFacturation: 'AdresseDeFacturation',
    AdresseDeLivraison: 'AdresseDeLivraison',
    NomDuDestinataire: 'NomDuDestinataire',
    Adresse: 'Adresse',
    Ville: 'Ville',
    NumeroDeTelephone: 'NumeroDeTelephone',
    CodePostal: 'CodePostal',
    Pays: 'Pays',
    IdClient: 'IdClient'
  };

  export type AdresseScalarFieldEnum = (typeof AdresseScalarFieldEnum)[keyof typeof AdresseScalarFieldEnum]


  export const ChoisitScalarFieldEnum: {
    IdClient: 'IdClient',
    IdMoto: 'IdMoto'
  };

  export type ChoisitScalarFieldEnum = (typeof ChoisitScalarFieldEnum)[keyof typeof ChoisitScalarFieldEnum]


  export const ClientScalarFieldEnum: {
    IdClient: 'IdClient',
    Nom: 'Nom',
    Prenom: 'Prenom',
    AddresseMail: 'AddresseMail',
    MotDePasse: 'MotDePasse',
    DateDeNaissance: 'DateDeNaissance',
    NumeroDeTelephone: 'NumeroDeTelephone',
    Anciennete: 'Anciennete'
  };

  export type ClientScalarFieldEnum = (typeof ClientScalarFieldEnum)[keyof typeof ClientScalarFieldEnum]


  export const CommandeScalarFieldEnum: {
    IdCommandes: 'IdCommandes',
    DatedeCommande: 'DatedeCommande',
    StatusDeLaCommande: 'StatusDeLaCommande',
    IdAdresse: 'IdAdresse',
    IdClient: 'IdClient'
  };

  export type CommandeScalarFieldEnum = (typeof CommandeScalarFieldEnum)[keyof typeof CommandeScalarFieldEnum]


  export const FactureScalarFieldEnum: {
    IdFactures: 'IdFactures',
    DatedeFacturation: 'DatedeFacturation',
    MontantTotal: 'MontantTotal',
    IdClient: 'IdClient'
  };

  export type FactureScalarFieldEnum = (typeof FactureScalarFieldEnum)[keyof typeof FactureScalarFieldEnum]


  export const InclutScalarFieldEnum: {
    IdMoto: 'IdMoto',
    IdCommandes: 'IdCommandes'
  };

  export type InclutScalarFieldEnum = (typeof InclutScalarFieldEnum)[keyof typeof InclutScalarFieldEnum]


  export const MethodedepaiementScalarFieldEnum: {
    IdPaiement: 'IdPaiement',
    TypePaiement: 'TypePaiement',
    InformationsDePaiement: 'InformationsDePaiement'
  };

  export type MethodedepaiementScalarFieldEnum = (typeof MethodedepaiementScalarFieldEnum)[keyof typeof MethodedepaiementScalarFieldEnum]


  export const MotosScalarFieldEnum: {
    IdMoto: 'IdMoto',
    NomMoto: 'NomMoto',
    Constructeur: 'Constructeur',
    Modele: 'Modele',
    DescriptionDuProduit: 'DescriptionDuProduit',
    Prix: 'Prix',
    Stock: 'Stock'
  };

  export type MotosScalarFieldEnum = (typeof MotosScalarFieldEnum)[keyof typeof MotosScalarFieldEnum]


  export const PanierScalarFieldEnum: {
    IdPanier: 'IdPanier',
    Quantite: 'Quantite',
    IdClient: 'IdClient'
  };

  export type PanierScalarFieldEnum = (typeof PanierScalarFieldEnum)[keyof typeof PanierScalarFieldEnum]


  export const UtiliseScalarFieldEnum: {
    IdPaiement: 'IdPaiement',
    IdClient: 'IdClient'
  };

  export type UtiliseScalarFieldEnum = (typeof UtiliseScalarFieldEnum)[keyof typeof UtiliseScalarFieldEnum]


  export const MotossurcommandeScalarFieldEnum: {
    commandeId: 'commandeId',
    motoId: 'motoId'
  };

  export type MotossurcommandeScalarFieldEnum = (typeof MotossurcommandeScalarFieldEnum)[keyof typeof MotossurcommandeScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type adresseWhereInput = {
    AND?: adresseWhereInput | adresseWhereInput[]
    OR?: adresseWhereInput[]
    NOT?: adresseWhereInput | adresseWhereInput[]
    IdAdresse?: IntFilter<"adresse"> | number
    AdresseDeFacturation?: StringFilter<"adresse"> | string
    AdresseDeLivraison?: StringFilter<"adresse"> | string
    NomDuDestinataire?: StringFilter<"adresse"> | string
    Adresse?: StringFilter<"adresse"> | string
    Ville?: StringFilter<"adresse"> | string
    NumeroDeTelephone?: StringFilter<"adresse"> | string
    CodePostal?: StringFilter<"adresse"> | string
    Pays?: StringFilter<"adresse"> | string
    IdClient?: IntNullableFilter<"adresse"> | number | null
  }

  export type adresseOrderByWithRelationInput = {
    IdAdresse?: SortOrder
    AdresseDeFacturation?: SortOrder
    AdresseDeLivraison?: SortOrder
    NomDuDestinataire?: SortOrder
    Adresse?: SortOrder
    Ville?: SortOrder
    NumeroDeTelephone?: SortOrder
    CodePostal?: SortOrder
    Pays?: SortOrder
    IdClient?: SortOrderInput | SortOrder
  }

  export type adresseWhereUniqueInput = Prisma.AtLeast<{
    IdAdresse?: number
    AND?: adresseWhereInput | adresseWhereInput[]
    OR?: adresseWhereInput[]
    NOT?: adresseWhereInput | adresseWhereInput[]
    AdresseDeFacturation?: StringFilter<"adresse"> | string
    AdresseDeLivraison?: StringFilter<"adresse"> | string
    NomDuDestinataire?: StringFilter<"adresse"> | string
    Adresse?: StringFilter<"adresse"> | string
    Ville?: StringFilter<"adresse"> | string
    NumeroDeTelephone?: StringFilter<"adresse"> | string
    CodePostal?: StringFilter<"adresse"> | string
    Pays?: StringFilter<"adresse"> | string
    IdClient?: IntNullableFilter<"adresse"> | number | null
  }, "IdAdresse">

  export type adresseOrderByWithAggregationInput = {
    IdAdresse?: SortOrder
    AdresseDeFacturation?: SortOrder
    AdresseDeLivraison?: SortOrder
    NomDuDestinataire?: SortOrder
    Adresse?: SortOrder
    Ville?: SortOrder
    NumeroDeTelephone?: SortOrder
    CodePostal?: SortOrder
    Pays?: SortOrder
    IdClient?: SortOrderInput | SortOrder
    _count?: adresseCountOrderByAggregateInput
    _avg?: adresseAvgOrderByAggregateInput
    _max?: adresseMaxOrderByAggregateInput
    _min?: adresseMinOrderByAggregateInput
    _sum?: adresseSumOrderByAggregateInput
  }

  export type adresseScalarWhereWithAggregatesInput = {
    AND?: adresseScalarWhereWithAggregatesInput | adresseScalarWhereWithAggregatesInput[]
    OR?: adresseScalarWhereWithAggregatesInput[]
    NOT?: adresseScalarWhereWithAggregatesInput | adresseScalarWhereWithAggregatesInput[]
    IdAdresse?: IntWithAggregatesFilter<"adresse"> | number
    AdresseDeFacturation?: StringWithAggregatesFilter<"adresse"> | string
    AdresseDeLivraison?: StringWithAggregatesFilter<"adresse"> | string
    NomDuDestinataire?: StringWithAggregatesFilter<"adresse"> | string
    Adresse?: StringWithAggregatesFilter<"adresse"> | string
    Ville?: StringWithAggregatesFilter<"adresse"> | string
    NumeroDeTelephone?: StringWithAggregatesFilter<"adresse"> | string
    CodePostal?: StringWithAggregatesFilter<"adresse"> | string
    Pays?: StringWithAggregatesFilter<"adresse"> | string
    IdClient?: IntNullableWithAggregatesFilter<"adresse"> | number | null
  }

  export type choisitWhereInput = {
    AND?: choisitWhereInput | choisitWhereInput[]
    OR?: choisitWhereInput[]
    NOT?: choisitWhereInput | choisitWhereInput[]
    IdClient?: IntFilter<"choisit"> | number
    IdMoto?: IntFilter<"choisit"> | number
  }

  export type choisitOrderByWithRelationInput = {
    IdClient?: SortOrder
    IdMoto?: SortOrder
  }

  export type choisitWhereUniqueInput = Prisma.AtLeast<{
    IdClient_IdMoto?: choisitIdClientIdMotoCompoundUniqueInput
    AND?: choisitWhereInput | choisitWhereInput[]
    OR?: choisitWhereInput[]
    NOT?: choisitWhereInput | choisitWhereInput[]
    IdClient?: IntFilter<"choisit"> | number
    IdMoto?: IntFilter<"choisit"> | number
  }, "IdClient_IdMoto">

  export type choisitOrderByWithAggregationInput = {
    IdClient?: SortOrder
    IdMoto?: SortOrder
    _count?: choisitCountOrderByAggregateInput
    _avg?: choisitAvgOrderByAggregateInput
    _max?: choisitMaxOrderByAggregateInput
    _min?: choisitMinOrderByAggregateInput
    _sum?: choisitSumOrderByAggregateInput
  }

  export type choisitScalarWhereWithAggregatesInput = {
    AND?: choisitScalarWhereWithAggregatesInput | choisitScalarWhereWithAggregatesInput[]
    OR?: choisitScalarWhereWithAggregatesInput[]
    NOT?: choisitScalarWhereWithAggregatesInput | choisitScalarWhereWithAggregatesInput[]
    IdClient?: IntWithAggregatesFilter<"choisit"> | number
    IdMoto?: IntWithAggregatesFilter<"choisit"> | number
  }

  export type clientWhereInput = {
    AND?: clientWhereInput | clientWhereInput[]
    OR?: clientWhereInput[]
    NOT?: clientWhereInput | clientWhereInput[]
    IdClient?: IntFilter<"client"> | number
    Nom?: StringFilter<"client"> | string
    Prenom?: StringFilter<"client"> | string
    AddresseMail?: StringFilter<"client"> | string
    MotDePasse?: StringFilter<"client"> | string
    DateDeNaissance?: StringNullableFilter<"client"> | string | null
    NumeroDeTelephone?: StringFilter<"client"> | string
    Anciennete?: StringNullableFilter<"client"> | string | null
  }

  export type clientOrderByWithRelationInput = {
    IdClient?: SortOrder
    Nom?: SortOrder
    Prenom?: SortOrder
    AddresseMail?: SortOrder
    MotDePasse?: SortOrder
    DateDeNaissance?: SortOrderInput | SortOrder
    NumeroDeTelephone?: SortOrder
    Anciennete?: SortOrderInput | SortOrder
  }

  export type clientWhereUniqueInput = Prisma.AtLeast<{
    IdClient?: number
    AddresseMail?: string
    NumeroDeTelephone?: string
    AND?: clientWhereInput | clientWhereInput[]
    OR?: clientWhereInput[]
    NOT?: clientWhereInput | clientWhereInput[]
    Nom?: StringFilter<"client"> | string
    Prenom?: StringFilter<"client"> | string
    MotDePasse?: StringFilter<"client"> | string
    DateDeNaissance?: StringNullableFilter<"client"> | string | null
    Anciennete?: StringNullableFilter<"client"> | string | null
  }, "IdClient" | "AddresseMail" | "NumeroDeTelephone">

  export type clientOrderByWithAggregationInput = {
    IdClient?: SortOrder
    Nom?: SortOrder
    Prenom?: SortOrder
    AddresseMail?: SortOrder
    MotDePasse?: SortOrder
    DateDeNaissance?: SortOrderInput | SortOrder
    NumeroDeTelephone?: SortOrder
    Anciennete?: SortOrderInput | SortOrder
    _count?: clientCountOrderByAggregateInput
    _avg?: clientAvgOrderByAggregateInput
    _max?: clientMaxOrderByAggregateInput
    _min?: clientMinOrderByAggregateInput
    _sum?: clientSumOrderByAggregateInput
  }

  export type clientScalarWhereWithAggregatesInput = {
    AND?: clientScalarWhereWithAggregatesInput | clientScalarWhereWithAggregatesInput[]
    OR?: clientScalarWhereWithAggregatesInput[]
    NOT?: clientScalarWhereWithAggregatesInput | clientScalarWhereWithAggregatesInput[]
    IdClient?: IntWithAggregatesFilter<"client"> | number
    Nom?: StringWithAggregatesFilter<"client"> | string
    Prenom?: StringWithAggregatesFilter<"client"> | string
    AddresseMail?: StringWithAggregatesFilter<"client"> | string
    MotDePasse?: StringWithAggregatesFilter<"client"> | string
    DateDeNaissance?: StringNullableWithAggregatesFilter<"client"> | string | null
    NumeroDeTelephone?: StringWithAggregatesFilter<"client"> | string
    Anciennete?: StringNullableWithAggregatesFilter<"client"> | string | null
  }

  export type commandeWhereInput = {
    AND?: commandeWhereInput | commandeWhereInput[]
    OR?: commandeWhereInput[]
    NOT?: commandeWhereInput | commandeWhereInput[]
    IdCommandes?: IntFilter<"commande"> | number
    DatedeCommande?: DateTimeFilter<"commande"> | Date | string
    StatusDeLaCommande?: StringFilter<"commande"> | string
    IdAdresse?: IntFilter<"commande"> | number
    IdClient?: IntFilter<"commande"> | number
  }

  export type commandeOrderByWithRelationInput = {
    IdCommandes?: SortOrder
    DatedeCommande?: SortOrder
    StatusDeLaCommande?: SortOrder
    IdAdresse?: SortOrder
    IdClient?: SortOrder
  }

  export type commandeWhereUniqueInput = Prisma.AtLeast<{
    IdCommandes?: number
    AND?: commandeWhereInput | commandeWhereInput[]
    OR?: commandeWhereInput[]
    NOT?: commandeWhereInput | commandeWhereInput[]
    DatedeCommande?: DateTimeFilter<"commande"> | Date | string
    StatusDeLaCommande?: StringFilter<"commande"> | string
    IdAdresse?: IntFilter<"commande"> | number
    IdClient?: IntFilter<"commande"> | number
  }, "IdCommandes">

  export type commandeOrderByWithAggregationInput = {
    IdCommandes?: SortOrder
    DatedeCommande?: SortOrder
    StatusDeLaCommande?: SortOrder
    IdAdresse?: SortOrder
    IdClient?: SortOrder
    _count?: commandeCountOrderByAggregateInput
    _avg?: commandeAvgOrderByAggregateInput
    _max?: commandeMaxOrderByAggregateInput
    _min?: commandeMinOrderByAggregateInput
    _sum?: commandeSumOrderByAggregateInput
  }

  export type commandeScalarWhereWithAggregatesInput = {
    AND?: commandeScalarWhereWithAggregatesInput | commandeScalarWhereWithAggregatesInput[]
    OR?: commandeScalarWhereWithAggregatesInput[]
    NOT?: commandeScalarWhereWithAggregatesInput | commandeScalarWhereWithAggregatesInput[]
    IdCommandes?: IntWithAggregatesFilter<"commande"> | number
    DatedeCommande?: DateTimeWithAggregatesFilter<"commande"> | Date | string
    StatusDeLaCommande?: StringWithAggregatesFilter<"commande"> | string
    IdAdresse?: IntWithAggregatesFilter<"commande"> | number
    IdClient?: IntWithAggregatesFilter<"commande"> | number
  }

  export type factureWhereInput = {
    AND?: factureWhereInput | factureWhereInput[]
    OR?: factureWhereInput[]
    NOT?: factureWhereInput | factureWhereInput[]
    IdFactures?: IntFilter<"facture"> | number
    DatedeFacturation?: DateTimeFilter<"facture"> | Date | string
    MontantTotal?: DecimalFilter<"facture"> | Decimal | DecimalJsLike | number | string
    IdClient?: IntFilter<"facture"> | number
  }

  export type factureOrderByWithRelationInput = {
    IdFactures?: SortOrder
    DatedeFacturation?: SortOrder
    MontantTotal?: SortOrder
    IdClient?: SortOrder
  }

  export type factureWhereUniqueInput = Prisma.AtLeast<{
    IdFactures?: number
    AND?: factureWhereInput | factureWhereInput[]
    OR?: factureWhereInput[]
    NOT?: factureWhereInput | factureWhereInput[]
    DatedeFacturation?: DateTimeFilter<"facture"> | Date | string
    MontantTotal?: DecimalFilter<"facture"> | Decimal | DecimalJsLike | number | string
    IdClient?: IntFilter<"facture"> | number
  }, "IdFactures">

  export type factureOrderByWithAggregationInput = {
    IdFactures?: SortOrder
    DatedeFacturation?: SortOrder
    MontantTotal?: SortOrder
    IdClient?: SortOrder
    _count?: factureCountOrderByAggregateInput
    _avg?: factureAvgOrderByAggregateInput
    _max?: factureMaxOrderByAggregateInput
    _min?: factureMinOrderByAggregateInput
    _sum?: factureSumOrderByAggregateInput
  }

  export type factureScalarWhereWithAggregatesInput = {
    AND?: factureScalarWhereWithAggregatesInput | factureScalarWhereWithAggregatesInput[]
    OR?: factureScalarWhereWithAggregatesInput[]
    NOT?: factureScalarWhereWithAggregatesInput | factureScalarWhereWithAggregatesInput[]
    IdFactures?: IntWithAggregatesFilter<"facture"> | number
    DatedeFacturation?: DateTimeWithAggregatesFilter<"facture"> | Date | string
    MontantTotal?: DecimalWithAggregatesFilter<"facture"> | Decimal | DecimalJsLike | number | string
    IdClient?: IntWithAggregatesFilter<"facture"> | number
  }

  export type inclutWhereInput = {
    AND?: inclutWhereInput | inclutWhereInput[]
    OR?: inclutWhereInput[]
    NOT?: inclutWhereInput | inclutWhereInput[]
    IdMoto?: IntFilter<"inclut"> | number
    IdCommandes?: IntFilter<"inclut"> | number
  }

  export type inclutOrderByWithRelationInput = {
    IdMoto?: SortOrder
    IdCommandes?: SortOrder
  }

  export type inclutWhereUniqueInput = Prisma.AtLeast<{
    IdMoto_IdCommandes?: inclutIdMotoIdCommandesCompoundUniqueInput
    AND?: inclutWhereInput | inclutWhereInput[]
    OR?: inclutWhereInput[]
    NOT?: inclutWhereInput | inclutWhereInput[]
    IdMoto?: IntFilter<"inclut"> | number
    IdCommandes?: IntFilter<"inclut"> | number
  }, "IdMoto_IdCommandes">

  export type inclutOrderByWithAggregationInput = {
    IdMoto?: SortOrder
    IdCommandes?: SortOrder
    _count?: inclutCountOrderByAggregateInput
    _avg?: inclutAvgOrderByAggregateInput
    _max?: inclutMaxOrderByAggregateInput
    _min?: inclutMinOrderByAggregateInput
    _sum?: inclutSumOrderByAggregateInput
  }

  export type inclutScalarWhereWithAggregatesInput = {
    AND?: inclutScalarWhereWithAggregatesInput | inclutScalarWhereWithAggregatesInput[]
    OR?: inclutScalarWhereWithAggregatesInput[]
    NOT?: inclutScalarWhereWithAggregatesInput | inclutScalarWhereWithAggregatesInput[]
    IdMoto?: IntWithAggregatesFilter<"inclut"> | number
    IdCommandes?: IntWithAggregatesFilter<"inclut"> | number
  }

  export type methodedepaiementWhereInput = {
    AND?: methodedepaiementWhereInput | methodedepaiementWhereInput[]
    OR?: methodedepaiementWhereInput[]
    NOT?: methodedepaiementWhereInput | methodedepaiementWhereInput[]
    IdPaiement?: IntFilter<"methodedepaiement"> | number
    TypePaiement?: StringFilter<"methodedepaiement"> | string
    InformationsDePaiement?: StringFilter<"methodedepaiement"> | string
  }

  export type methodedepaiementOrderByWithRelationInput = {
    IdPaiement?: SortOrder
    TypePaiement?: SortOrder
    InformationsDePaiement?: SortOrder
  }

  export type methodedepaiementWhereUniqueInput = Prisma.AtLeast<{
    IdPaiement?: number
    AND?: methodedepaiementWhereInput | methodedepaiementWhereInput[]
    OR?: methodedepaiementWhereInput[]
    NOT?: methodedepaiementWhereInput | methodedepaiementWhereInput[]
    TypePaiement?: StringFilter<"methodedepaiement"> | string
    InformationsDePaiement?: StringFilter<"methodedepaiement"> | string
  }, "IdPaiement">

  export type methodedepaiementOrderByWithAggregationInput = {
    IdPaiement?: SortOrder
    TypePaiement?: SortOrder
    InformationsDePaiement?: SortOrder
    _count?: methodedepaiementCountOrderByAggregateInput
    _avg?: methodedepaiementAvgOrderByAggregateInput
    _max?: methodedepaiementMaxOrderByAggregateInput
    _min?: methodedepaiementMinOrderByAggregateInput
    _sum?: methodedepaiementSumOrderByAggregateInput
  }

  export type methodedepaiementScalarWhereWithAggregatesInput = {
    AND?: methodedepaiementScalarWhereWithAggregatesInput | methodedepaiementScalarWhereWithAggregatesInput[]
    OR?: methodedepaiementScalarWhereWithAggregatesInput[]
    NOT?: methodedepaiementScalarWhereWithAggregatesInput | methodedepaiementScalarWhereWithAggregatesInput[]
    IdPaiement?: IntWithAggregatesFilter<"methodedepaiement"> | number
    TypePaiement?: StringWithAggregatesFilter<"methodedepaiement"> | string
    InformationsDePaiement?: StringWithAggregatesFilter<"methodedepaiement"> | string
  }

  export type motosWhereInput = {
    AND?: motosWhereInput | motosWhereInput[]
    OR?: motosWhereInput[]
    NOT?: motosWhereInput | motosWhereInput[]
    IdMoto?: IntFilter<"motos"> | number
    NomMoto?: StringFilter<"motos"> | string
    Constructeur?: StringFilter<"motos"> | string
    Modele?: StringFilter<"motos"> | string
    DescriptionDuProduit?: StringFilter<"motos"> | string
    Prix?: DecimalFilter<"motos"> | Decimal | DecimalJsLike | number | string
    Stock?: IntFilter<"motos"> | number
  }

  export type motosOrderByWithRelationInput = {
    IdMoto?: SortOrder
    NomMoto?: SortOrder
    Constructeur?: SortOrder
    Modele?: SortOrder
    DescriptionDuProduit?: SortOrder
    Prix?: SortOrder
    Stock?: SortOrder
  }

  export type motosWhereUniqueInput = Prisma.AtLeast<{
    IdMoto?: number
    AND?: motosWhereInput | motosWhereInput[]
    OR?: motosWhereInput[]
    NOT?: motosWhereInput | motosWhereInput[]
    NomMoto?: StringFilter<"motos"> | string
    Constructeur?: StringFilter<"motos"> | string
    Modele?: StringFilter<"motos"> | string
    DescriptionDuProduit?: StringFilter<"motos"> | string
    Prix?: DecimalFilter<"motos"> | Decimal | DecimalJsLike | number | string
    Stock?: IntFilter<"motos"> | number
  }, "IdMoto">

  export type motosOrderByWithAggregationInput = {
    IdMoto?: SortOrder
    NomMoto?: SortOrder
    Constructeur?: SortOrder
    Modele?: SortOrder
    DescriptionDuProduit?: SortOrder
    Prix?: SortOrder
    Stock?: SortOrder
    _count?: motosCountOrderByAggregateInput
    _avg?: motosAvgOrderByAggregateInput
    _max?: motosMaxOrderByAggregateInput
    _min?: motosMinOrderByAggregateInput
    _sum?: motosSumOrderByAggregateInput
  }

  export type motosScalarWhereWithAggregatesInput = {
    AND?: motosScalarWhereWithAggregatesInput | motosScalarWhereWithAggregatesInput[]
    OR?: motosScalarWhereWithAggregatesInput[]
    NOT?: motosScalarWhereWithAggregatesInput | motosScalarWhereWithAggregatesInput[]
    IdMoto?: IntWithAggregatesFilter<"motos"> | number
    NomMoto?: StringWithAggregatesFilter<"motos"> | string
    Constructeur?: StringWithAggregatesFilter<"motos"> | string
    Modele?: StringWithAggregatesFilter<"motos"> | string
    DescriptionDuProduit?: StringWithAggregatesFilter<"motos"> | string
    Prix?: DecimalWithAggregatesFilter<"motos"> | Decimal | DecimalJsLike | number | string
    Stock?: IntWithAggregatesFilter<"motos"> | number
  }

  export type panierWhereInput = {
    AND?: panierWhereInput | panierWhereInput[]
    OR?: panierWhereInput[]
    NOT?: panierWhereInput | panierWhereInput[]
    IdPanier?: IntFilter<"panier"> | number
    Quantite?: BigIntFilter<"panier"> | bigint | number
    IdClient?: IntFilter<"panier"> | number
  }

  export type panierOrderByWithRelationInput = {
    IdPanier?: SortOrder
    Quantite?: SortOrder
    IdClient?: SortOrder
  }

  export type panierWhereUniqueInput = Prisma.AtLeast<{
    IdPanier?: number
    AND?: panierWhereInput | panierWhereInput[]
    OR?: panierWhereInput[]
    NOT?: panierWhereInput | panierWhereInput[]
    Quantite?: BigIntFilter<"panier"> | bigint | number
    IdClient?: IntFilter<"panier"> | number
  }, "IdPanier">

  export type panierOrderByWithAggregationInput = {
    IdPanier?: SortOrder
    Quantite?: SortOrder
    IdClient?: SortOrder
    _count?: panierCountOrderByAggregateInput
    _avg?: panierAvgOrderByAggregateInput
    _max?: panierMaxOrderByAggregateInput
    _min?: panierMinOrderByAggregateInput
    _sum?: panierSumOrderByAggregateInput
  }

  export type panierScalarWhereWithAggregatesInput = {
    AND?: panierScalarWhereWithAggregatesInput | panierScalarWhereWithAggregatesInput[]
    OR?: panierScalarWhereWithAggregatesInput[]
    NOT?: panierScalarWhereWithAggregatesInput | panierScalarWhereWithAggregatesInput[]
    IdPanier?: IntWithAggregatesFilter<"panier"> | number
    Quantite?: BigIntWithAggregatesFilter<"panier"> | bigint | number
    IdClient?: IntWithAggregatesFilter<"panier"> | number
  }

  export type utiliseWhereInput = {
    AND?: utiliseWhereInput | utiliseWhereInput[]
    OR?: utiliseWhereInput[]
    NOT?: utiliseWhereInput | utiliseWhereInput[]
    IdPaiement?: IntFilter<"utilise"> | number
    IdClient?: IntFilter<"utilise"> | number
  }

  export type utiliseOrderByWithRelationInput = {
    IdPaiement?: SortOrder
    IdClient?: SortOrder
  }

  export type utiliseWhereUniqueInput = Prisma.AtLeast<{
    IdPaiement_IdClient?: utiliseIdPaiementIdClientCompoundUniqueInput
    AND?: utiliseWhereInput | utiliseWhereInput[]
    OR?: utiliseWhereInput[]
    NOT?: utiliseWhereInput | utiliseWhereInput[]
    IdPaiement?: IntFilter<"utilise"> | number
    IdClient?: IntFilter<"utilise"> | number
  }, "IdPaiement_IdClient">

  export type utiliseOrderByWithAggregationInput = {
    IdPaiement?: SortOrder
    IdClient?: SortOrder
    _count?: utiliseCountOrderByAggregateInput
    _avg?: utiliseAvgOrderByAggregateInput
    _max?: utiliseMaxOrderByAggregateInput
    _min?: utiliseMinOrderByAggregateInput
    _sum?: utiliseSumOrderByAggregateInput
  }

  export type utiliseScalarWhereWithAggregatesInput = {
    AND?: utiliseScalarWhereWithAggregatesInput | utiliseScalarWhereWithAggregatesInput[]
    OR?: utiliseScalarWhereWithAggregatesInput[]
    NOT?: utiliseScalarWhereWithAggregatesInput | utiliseScalarWhereWithAggregatesInput[]
    IdPaiement?: IntWithAggregatesFilter<"utilise"> | number
    IdClient?: IntWithAggregatesFilter<"utilise"> | number
  }

  export type motossurcommandeWhereInput = {
    AND?: motossurcommandeWhereInput | motossurcommandeWhereInput[]
    OR?: motossurcommandeWhereInput[]
    NOT?: motossurcommandeWhereInput | motossurcommandeWhereInput[]
    commandeId?: IntFilter<"motossurcommande"> | number
    motoId?: IntFilter<"motossurcommande"> | number
  }

  export type motossurcommandeOrderByWithRelationInput = {
    commandeId?: SortOrder
    motoId?: SortOrder
  }

  export type motossurcommandeWhereUniqueInput = Prisma.AtLeast<{
    commandeId_motoId?: motossurcommandeCommandeIdMotoIdCompoundUniqueInput
    AND?: motossurcommandeWhereInput | motossurcommandeWhereInput[]
    OR?: motossurcommandeWhereInput[]
    NOT?: motossurcommandeWhereInput | motossurcommandeWhereInput[]
    commandeId?: IntFilter<"motossurcommande"> | number
    motoId?: IntFilter<"motossurcommande"> | number
  }, "commandeId_motoId">

  export type motossurcommandeOrderByWithAggregationInput = {
    commandeId?: SortOrder
    motoId?: SortOrder
    _count?: motossurcommandeCountOrderByAggregateInput
    _avg?: motossurcommandeAvgOrderByAggregateInput
    _max?: motossurcommandeMaxOrderByAggregateInput
    _min?: motossurcommandeMinOrderByAggregateInput
    _sum?: motossurcommandeSumOrderByAggregateInput
  }

  export type motossurcommandeScalarWhereWithAggregatesInput = {
    AND?: motossurcommandeScalarWhereWithAggregatesInput | motossurcommandeScalarWhereWithAggregatesInput[]
    OR?: motossurcommandeScalarWhereWithAggregatesInput[]
    NOT?: motossurcommandeScalarWhereWithAggregatesInput | motossurcommandeScalarWhereWithAggregatesInput[]
    commandeId?: IntWithAggregatesFilter<"motossurcommande"> | number
    motoId?: IntWithAggregatesFilter<"motossurcommande"> | number
  }

  export type adresseCreateInput = {
    AdresseDeFacturation: string
    AdresseDeLivraison: string
    NomDuDestinataire: string
    Adresse: string
    Ville: string
    NumeroDeTelephone: string
    CodePostal: string
    Pays: string
    IdClient?: number | null
  }

  export type adresseUncheckedCreateInput = {
    IdAdresse?: number
    AdresseDeFacturation: string
    AdresseDeLivraison: string
    NomDuDestinataire: string
    Adresse: string
    Ville: string
    NumeroDeTelephone: string
    CodePostal: string
    Pays: string
    IdClient?: number | null
  }

  export type adresseUpdateInput = {
    AdresseDeFacturation?: StringFieldUpdateOperationsInput | string
    AdresseDeLivraison?: StringFieldUpdateOperationsInput | string
    NomDuDestinataire?: StringFieldUpdateOperationsInput | string
    Adresse?: StringFieldUpdateOperationsInput | string
    Ville?: StringFieldUpdateOperationsInput | string
    NumeroDeTelephone?: StringFieldUpdateOperationsInput | string
    CodePostal?: StringFieldUpdateOperationsInput | string
    Pays?: StringFieldUpdateOperationsInput | string
    IdClient?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type adresseUncheckedUpdateInput = {
    IdAdresse?: IntFieldUpdateOperationsInput | number
    AdresseDeFacturation?: StringFieldUpdateOperationsInput | string
    AdresseDeLivraison?: StringFieldUpdateOperationsInput | string
    NomDuDestinataire?: StringFieldUpdateOperationsInput | string
    Adresse?: StringFieldUpdateOperationsInput | string
    Ville?: StringFieldUpdateOperationsInput | string
    NumeroDeTelephone?: StringFieldUpdateOperationsInput | string
    CodePostal?: StringFieldUpdateOperationsInput | string
    Pays?: StringFieldUpdateOperationsInput | string
    IdClient?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type adresseCreateManyInput = {
    IdAdresse?: number
    AdresseDeFacturation: string
    AdresseDeLivraison: string
    NomDuDestinataire: string
    Adresse: string
    Ville: string
    NumeroDeTelephone: string
    CodePostal: string
    Pays: string
    IdClient?: number | null
  }

  export type adresseUpdateManyMutationInput = {
    AdresseDeFacturation?: StringFieldUpdateOperationsInput | string
    AdresseDeLivraison?: StringFieldUpdateOperationsInput | string
    NomDuDestinataire?: StringFieldUpdateOperationsInput | string
    Adresse?: StringFieldUpdateOperationsInput | string
    Ville?: StringFieldUpdateOperationsInput | string
    NumeroDeTelephone?: StringFieldUpdateOperationsInput | string
    CodePostal?: StringFieldUpdateOperationsInput | string
    Pays?: StringFieldUpdateOperationsInput | string
    IdClient?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type adresseUncheckedUpdateManyInput = {
    IdAdresse?: IntFieldUpdateOperationsInput | number
    AdresseDeFacturation?: StringFieldUpdateOperationsInput | string
    AdresseDeLivraison?: StringFieldUpdateOperationsInput | string
    NomDuDestinataire?: StringFieldUpdateOperationsInput | string
    Adresse?: StringFieldUpdateOperationsInput | string
    Ville?: StringFieldUpdateOperationsInput | string
    NumeroDeTelephone?: StringFieldUpdateOperationsInput | string
    CodePostal?: StringFieldUpdateOperationsInput | string
    Pays?: StringFieldUpdateOperationsInput | string
    IdClient?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type choisitCreateInput = {
    IdClient: number
    IdMoto: number
  }

  export type choisitUncheckedCreateInput = {
    IdClient: number
    IdMoto: number
  }

  export type choisitUpdateInput = {
    IdClient?: IntFieldUpdateOperationsInput | number
    IdMoto?: IntFieldUpdateOperationsInput | number
  }

  export type choisitUncheckedUpdateInput = {
    IdClient?: IntFieldUpdateOperationsInput | number
    IdMoto?: IntFieldUpdateOperationsInput | number
  }

  export type choisitCreateManyInput = {
    IdClient: number
    IdMoto: number
  }

  export type choisitUpdateManyMutationInput = {
    IdClient?: IntFieldUpdateOperationsInput | number
    IdMoto?: IntFieldUpdateOperationsInput | number
  }

  export type choisitUncheckedUpdateManyInput = {
    IdClient?: IntFieldUpdateOperationsInput | number
    IdMoto?: IntFieldUpdateOperationsInput | number
  }

  export type clientCreateInput = {
    Nom: string
    Prenom: string
    AddresseMail: string
    MotDePasse: string
    DateDeNaissance?: string | null
    NumeroDeTelephone: string
    Anciennete?: string | null
  }

  export type clientUncheckedCreateInput = {
    IdClient?: number
    Nom: string
    Prenom: string
    AddresseMail: string
    MotDePasse: string
    DateDeNaissance?: string | null
    NumeroDeTelephone: string
    Anciennete?: string | null
  }

  export type clientUpdateInput = {
    Nom?: StringFieldUpdateOperationsInput | string
    Prenom?: StringFieldUpdateOperationsInput | string
    AddresseMail?: StringFieldUpdateOperationsInput | string
    MotDePasse?: StringFieldUpdateOperationsInput | string
    DateDeNaissance?: NullableStringFieldUpdateOperationsInput | string | null
    NumeroDeTelephone?: StringFieldUpdateOperationsInput | string
    Anciennete?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type clientUncheckedUpdateInput = {
    IdClient?: IntFieldUpdateOperationsInput | number
    Nom?: StringFieldUpdateOperationsInput | string
    Prenom?: StringFieldUpdateOperationsInput | string
    AddresseMail?: StringFieldUpdateOperationsInput | string
    MotDePasse?: StringFieldUpdateOperationsInput | string
    DateDeNaissance?: NullableStringFieldUpdateOperationsInput | string | null
    NumeroDeTelephone?: StringFieldUpdateOperationsInput | string
    Anciennete?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type clientCreateManyInput = {
    IdClient?: number
    Nom: string
    Prenom: string
    AddresseMail: string
    MotDePasse: string
    DateDeNaissance?: string | null
    NumeroDeTelephone: string
    Anciennete?: string | null
  }

  export type clientUpdateManyMutationInput = {
    Nom?: StringFieldUpdateOperationsInput | string
    Prenom?: StringFieldUpdateOperationsInput | string
    AddresseMail?: StringFieldUpdateOperationsInput | string
    MotDePasse?: StringFieldUpdateOperationsInput | string
    DateDeNaissance?: NullableStringFieldUpdateOperationsInput | string | null
    NumeroDeTelephone?: StringFieldUpdateOperationsInput | string
    Anciennete?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type clientUncheckedUpdateManyInput = {
    IdClient?: IntFieldUpdateOperationsInput | number
    Nom?: StringFieldUpdateOperationsInput | string
    Prenom?: StringFieldUpdateOperationsInput | string
    AddresseMail?: StringFieldUpdateOperationsInput | string
    MotDePasse?: StringFieldUpdateOperationsInput | string
    DateDeNaissance?: NullableStringFieldUpdateOperationsInput | string | null
    NumeroDeTelephone?: StringFieldUpdateOperationsInput | string
    Anciennete?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type commandeCreateInput = {
    DatedeCommande: Date | string
    StatusDeLaCommande: string
    IdAdresse: number
    IdClient: number
  }

  export type commandeUncheckedCreateInput = {
    IdCommandes?: number
    DatedeCommande: Date | string
    StatusDeLaCommande: string
    IdAdresse: number
    IdClient: number
  }

  export type commandeUpdateInput = {
    DatedeCommande?: DateTimeFieldUpdateOperationsInput | Date | string
    StatusDeLaCommande?: StringFieldUpdateOperationsInput | string
    IdAdresse?: IntFieldUpdateOperationsInput | number
    IdClient?: IntFieldUpdateOperationsInput | number
  }

  export type commandeUncheckedUpdateInput = {
    IdCommandes?: IntFieldUpdateOperationsInput | number
    DatedeCommande?: DateTimeFieldUpdateOperationsInput | Date | string
    StatusDeLaCommande?: StringFieldUpdateOperationsInput | string
    IdAdresse?: IntFieldUpdateOperationsInput | number
    IdClient?: IntFieldUpdateOperationsInput | number
  }

  export type commandeCreateManyInput = {
    IdCommandes?: number
    DatedeCommande: Date | string
    StatusDeLaCommande: string
    IdAdresse: number
    IdClient: number
  }

  export type commandeUpdateManyMutationInput = {
    DatedeCommande?: DateTimeFieldUpdateOperationsInput | Date | string
    StatusDeLaCommande?: StringFieldUpdateOperationsInput | string
    IdAdresse?: IntFieldUpdateOperationsInput | number
    IdClient?: IntFieldUpdateOperationsInput | number
  }

  export type commandeUncheckedUpdateManyInput = {
    IdCommandes?: IntFieldUpdateOperationsInput | number
    DatedeCommande?: DateTimeFieldUpdateOperationsInput | Date | string
    StatusDeLaCommande?: StringFieldUpdateOperationsInput | string
    IdAdresse?: IntFieldUpdateOperationsInput | number
    IdClient?: IntFieldUpdateOperationsInput | number
  }

  export type factureCreateInput = {
    DatedeFacturation: Date | string
    MontantTotal: Decimal | DecimalJsLike | number | string
    IdClient: number
  }

  export type factureUncheckedCreateInput = {
    IdFactures?: number
    DatedeFacturation: Date | string
    MontantTotal: Decimal | DecimalJsLike | number | string
    IdClient: number
  }

  export type factureUpdateInput = {
    DatedeFacturation?: DateTimeFieldUpdateOperationsInput | Date | string
    MontantTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    IdClient?: IntFieldUpdateOperationsInput | number
  }

  export type factureUncheckedUpdateInput = {
    IdFactures?: IntFieldUpdateOperationsInput | number
    DatedeFacturation?: DateTimeFieldUpdateOperationsInput | Date | string
    MontantTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    IdClient?: IntFieldUpdateOperationsInput | number
  }

  export type factureCreateManyInput = {
    IdFactures?: number
    DatedeFacturation: Date | string
    MontantTotal: Decimal | DecimalJsLike | number | string
    IdClient: number
  }

  export type factureUpdateManyMutationInput = {
    DatedeFacturation?: DateTimeFieldUpdateOperationsInput | Date | string
    MontantTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    IdClient?: IntFieldUpdateOperationsInput | number
  }

  export type factureUncheckedUpdateManyInput = {
    IdFactures?: IntFieldUpdateOperationsInput | number
    DatedeFacturation?: DateTimeFieldUpdateOperationsInput | Date | string
    MontantTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    IdClient?: IntFieldUpdateOperationsInput | number
  }

  export type inclutCreateInput = {
    IdMoto: number
    IdCommandes: number
  }

  export type inclutUncheckedCreateInput = {
    IdMoto: number
    IdCommandes: number
  }

  export type inclutUpdateInput = {
    IdMoto?: IntFieldUpdateOperationsInput | number
    IdCommandes?: IntFieldUpdateOperationsInput | number
  }

  export type inclutUncheckedUpdateInput = {
    IdMoto?: IntFieldUpdateOperationsInput | number
    IdCommandes?: IntFieldUpdateOperationsInput | number
  }

  export type inclutCreateManyInput = {
    IdMoto: number
    IdCommandes: number
  }

  export type inclutUpdateManyMutationInput = {
    IdMoto?: IntFieldUpdateOperationsInput | number
    IdCommandes?: IntFieldUpdateOperationsInput | number
  }

  export type inclutUncheckedUpdateManyInput = {
    IdMoto?: IntFieldUpdateOperationsInput | number
    IdCommandes?: IntFieldUpdateOperationsInput | number
  }

  export type methodedepaiementCreateInput = {
    TypePaiement: string
    InformationsDePaiement: string
  }

  export type methodedepaiementUncheckedCreateInput = {
    IdPaiement?: number
    TypePaiement: string
    InformationsDePaiement: string
  }

  export type methodedepaiementUpdateInput = {
    TypePaiement?: StringFieldUpdateOperationsInput | string
    InformationsDePaiement?: StringFieldUpdateOperationsInput | string
  }

  export type methodedepaiementUncheckedUpdateInput = {
    IdPaiement?: IntFieldUpdateOperationsInput | number
    TypePaiement?: StringFieldUpdateOperationsInput | string
    InformationsDePaiement?: StringFieldUpdateOperationsInput | string
  }

  export type methodedepaiementCreateManyInput = {
    IdPaiement?: number
    TypePaiement: string
    InformationsDePaiement: string
  }

  export type methodedepaiementUpdateManyMutationInput = {
    TypePaiement?: StringFieldUpdateOperationsInput | string
    InformationsDePaiement?: StringFieldUpdateOperationsInput | string
  }

  export type methodedepaiementUncheckedUpdateManyInput = {
    IdPaiement?: IntFieldUpdateOperationsInput | number
    TypePaiement?: StringFieldUpdateOperationsInput | string
    InformationsDePaiement?: StringFieldUpdateOperationsInput | string
  }

  export type motosCreateInput = {
    NomMoto: string
    Constructeur: string
    Modele: string
    DescriptionDuProduit: string
    Prix: Decimal | DecimalJsLike | number | string
    Stock: number
  }

  export type motosUncheckedCreateInput = {
    IdMoto?: number
    NomMoto: string
    Constructeur: string
    Modele: string
    DescriptionDuProduit: string
    Prix: Decimal | DecimalJsLike | number | string
    Stock: number
  }

  export type motosUpdateInput = {
    NomMoto?: StringFieldUpdateOperationsInput | string
    Constructeur?: StringFieldUpdateOperationsInput | string
    Modele?: StringFieldUpdateOperationsInput | string
    DescriptionDuProduit?: StringFieldUpdateOperationsInput | string
    Prix?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Stock?: IntFieldUpdateOperationsInput | number
  }

  export type motosUncheckedUpdateInput = {
    IdMoto?: IntFieldUpdateOperationsInput | number
    NomMoto?: StringFieldUpdateOperationsInput | string
    Constructeur?: StringFieldUpdateOperationsInput | string
    Modele?: StringFieldUpdateOperationsInput | string
    DescriptionDuProduit?: StringFieldUpdateOperationsInput | string
    Prix?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Stock?: IntFieldUpdateOperationsInput | number
  }

  export type motosCreateManyInput = {
    IdMoto?: number
    NomMoto: string
    Constructeur: string
    Modele: string
    DescriptionDuProduit: string
    Prix: Decimal | DecimalJsLike | number | string
    Stock: number
  }

  export type motosUpdateManyMutationInput = {
    NomMoto?: StringFieldUpdateOperationsInput | string
    Constructeur?: StringFieldUpdateOperationsInput | string
    Modele?: StringFieldUpdateOperationsInput | string
    DescriptionDuProduit?: StringFieldUpdateOperationsInput | string
    Prix?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Stock?: IntFieldUpdateOperationsInput | number
  }

  export type motosUncheckedUpdateManyInput = {
    IdMoto?: IntFieldUpdateOperationsInput | number
    NomMoto?: StringFieldUpdateOperationsInput | string
    Constructeur?: StringFieldUpdateOperationsInput | string
    Modele?: StringFieldUpdateOperationsInput | string
    DescriptionDuProduit?: StringFieldUpdateOperationsInput | string
    Prix?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Stock?: IntFieldUpdateOperationsInput | number
  }

  export type panierCreateInput = {
    Quantite: bigint | number
    IdClient: number
  }

  export type panierUncheckedCreateInput = {
    IdPanier?: number
    Quantite: bigint | number
    IdClient: number
  }

  export type panierUpdateInput = {
    Quantite?: BigIntFieldUpdateOperationsInput | bigint | number
    IdClient?: IntFieldUpdateOperationsInput | number
  }

  export type panierUncheckedUpdateInput = {
    IdPanier?: IntFieldUpdateOperationsInput | number
    Quantite?: BigIntFieldUpdateOperationsInput | bigint | number
    IdClient?: IntFieldUpdateOperationsInput | number
  }

  export type panierCreateManyInput = {
    IdPanier?: number
    Quantite: bigint | number
    IdClient: number
  }

  export type panierUpdateManyMutationInput = {
    Quantite?: BigIntFieldUpdateOperationsInput | bigint | number
    IdClient?: IntFieldUpdateOperationsInput | number
  }

  export type panierUncheckedUpdateManyInput = {
    IdPanier?: IntFieldUpdateOperationsInput | number
    Quantite?: BigIntFieldUpdateOperationsInput | bigint | number
    IdClient?: IntFieldUpdateOperationsInput | number
  }

  export type utiliseCreateInput = {
    IdPaiement: number
    IdClient: number
  }

  export type utiliseUncheckedCreateInput = {
    IdPaiement: number
    IdClient: number
  }

  export type utiliseUpdateInput = {
    IdPaiement?: IntFieldUpdateOperationsInput | number
    IdClient?: IntFieldUpdateOperationsInput | number
  }

  export type utiliseUncheckedUpdateInput = {
    IdPaiement?: IntFieldUpdateOperationsInput | number
    IdClient?: IntFieldUpdateOperationsInput | number
  }

  export type utiliseCreateManyInput = {
    IdPaiement: number
    IdClient: number
  }

  export type utiliseUpdateManyMutationInput = {
    IdPaiement?: IntFieldUpdateOperationsInput | number
    IdClient?: IntFieldUpdateOperationsInput | number
  }

  export type utiliseUncheckedUpdateManyInput = {
    IdPaiement?: IntFieldUpdateOperationsInput | number
    IdClient?: IntFieldUpdateOperationsInput | number
  }

  export type motossurcommandeCreateInput = {
    commandeId: number
    motoId: number
  }

  export type motossurcommandeUncheckedCreateInput = {
    commandeId: number
    motoId: number
  }

  export type motossurcommandeUpdateInput = {
    commandeId?: IntFieldUpdateOperationsInput | number
    motoId?: IntFieldUpdateOperationsInput | number
  }

  export type motossurcommandeUncheckedUpdateInput = {
    commandeId?: IntFieldUpdateOperationsInput | number
    motoId?: IntFieldUpdateOperationsInput | number
  }

  export type motossurcommandeCreateManyInput = {
    commandeId: number
    motoId: number
  }

  export type motossurcommandeUpdateManyMutationInput = {
    commandeId?: IntFieldUpdateOperationsInput | number
    motoId?: IntFieldUpdateOperationsInput | number
  }

  export type motossurcommandeUncheckedUpdateManyInput = {
    commandeId?: IntFieldUpdateOperationsInput | number
    motoId?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type adresseCountOrderByAggregateInput = {
    IdAdresse?: SortOrder
    AdresseDeFacturation?: SortOrder
    AdresseDeLivraison?: SortOrder
    NomDuDestinataire?: SortOrder
    Adresse?: SortOrder
    Ville?: SortOrder
    NumeroDeTelephone?: SortOrder
    CodePostal?: SortOrder
    Pays?: SortOrder
    IdClient?: SortOrder
  }

  export type adresseAvgOrderByAggregateInput = {
    IdAdresse?: SortOrder
    IdClient?: SortOrder
  }

  export type adresseMaxOrderByAggregateInput = {
    IdAdresse?: SortOrder
    AdresseDeFacturation?: SortOrder
    AdresseDeLivraison?: SortOrder
    NomDuDestinataire?: SortOrder
    Adresse?: SortOrder
    Ville?: SortOrder
    NumeroDeTelephone?: SortOrder
    CodePostal?: SortOrder
    Pays?: SortOrder
    IdClient?: SortOrder
  }

  export type adresseMinOrderByAggregateInput = {
    IdAdresse?: SortOrder
    AdresseDeFacturation?: SortOrder
    AdresseDeLivraison?: SortOrder
    NomDuDestinataire?: SortOrder
    Adresse?: SortOrder
    Ville?: SortOrder
    NumeroDeTelephone?: SortOrder
    CodePostal?: SortOrder
    Pays?: SortOrder
    IdClient?: SortOrder
  }

  export type adresseSumOrderByAggregateInput = {
    IdAdresse?: SortOrder
    IdClient?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type choisitIdClientIdMotoCompoundUniqueInput = {
    IdClient: number
    IdMoto: number
  }

  export type choisitCountOrderByAggregateInput = {
    IdClient?: SortOrder
    IdMoto?: SortOrder
  }

  export type choisitAvgOrderByAggregateInput = {
    IdClient?: SortOrder
    IdMoto?: SortOrder
  }

  export type choisitMaxOrderByAggregateInput = {
    IdClient?: SortOrder
    IdMoto?: SortOrder
  }

  export type choisitMinOrderByAggregateInput = {
    IdClient?: SortOrder
    IdMoto?: SortOrder
  }

  export type choisitSumOrderByAggregateInput = {
    IdClient?: SortOrder
    IdMoto?: SortOrder
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type clientCountOrderByAggregateInput = {
    IdClient?: SortOrder
    Nom?: SortOrder
    Prenom?: SortOrder
    AddresseMail?: SortOrder
    MotDePasse?: SortOrder
    DateDeNaissance?: SortOrder
    NumeroDeTelephone?: SortOrder
    Anciennete?: SortOrder
  }

  export type clientAvgOrderByAggregateInput = {
    IdClient?: SortOrder
  }

  export type clientMaxOrderByAggregateInput = {
    IdClient?: SortOrder
    Nom?: SortOrder
    Prenom?: SortOrder
    AddresseMail?: SortOrder
    MotDePasse?: SortOrder
    DateDeNaissance?: SortOrder
    NumeroDeTelephone?: SortOrder
    Anciennete?: SortOrder
  }

  export type clientMinOrderByAggregateInput = {
    IdClient?: SortOrder
    Nom?: SortOrder
    Prenom?: SortOrder
    AddresseMail?: SortOrder
    MotDePasse?: SortOrder
    DateDeNaissance?: SortOrder
    NumeroDeTelephone?: SortOrder
    Anciennete?: SortOrder
  }

  export type clientSumOrderByAggregateInput = {
    IdClient?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type commandeCountOrderByAggregateInput = {
    IdCommandes?: SortOrder
    DatedeCommande?: SortOrder
    StatusDeLaCommande?: SortOrder
    IdAdresse?: SortOrder
    IdClient?: SortOrder
  }

  export type commandeAvgOrderByAggregateInput = {
    IdCommandes?: SortOrder
    IdAdresse?: SortOrder
    IdClient?: SortOrder
  }

  export type commandeMaxOrderByAggregateInput = {
    IdCommandes?: SortOrder
    DatedeCommande?: SortOrder
    StatusDeLaCommande?: SortOrder
    IdAdresse?: SortOrder
    IdClient?: SortOrder
  }

  export type commandeMinOrderByAggregateInput = {
    IdCommandes?: SortOrder
    DatedeCommande?: SortOrder
    StatusDeLaCommande?: SortOrder
    IdAdresse?: SortOrder
    IdClient?: SortOrder
  }

  export type commandeSumOrderByAggregateInput = {
    IdCommandes?: SortOrder
    IdAdresse?: SortOrder
    IdClient?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type factureCountOrderByAggregateInput = {
    IdFactures?: SortOrder
    DatedeFacturation?: SortOrder
    MontantTotal?: SortOrder
    IdClient?: SortOrder
  }

  export type factureAvgOrderByAggregateInput = {
    IdFactures?: SortOrder
    MontantTotal?: SortOrder
    IdClient?: SortOrder
  }

  export type factureMaxOrderByAggregateInput = {
    IdFactures?: SortOrder
    DatedeFacturation?: SortOrder
    MontantTotal?: SortOrder
    IdClient?: SortOrder
  }

  export type factureMinOrderByAggregateInput = {
    IdFactures?: SortOrder
    DatedeFacturation?: SortOrder
    MontantTotal?: SortOrder
    IdClient?: SortOrder
  }

  export type factureSumOrderByAggregateInput = {
    IdFactures?: SortOrder
    MontantTotal?: SortOrder
    IdClient?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type inclutIdMotoIdCommandesCompoundUniqueInput = {
    IdMoto: number
    IdCommandes: number
  }

  export type inclutCountOrderByAggregateInput = {
    IdMoto?: SortOrder
    IdCommandes?: SortOrder
  }

  export type inclutAvgOrderByAggregateInput = {
    IdMoto?: SortOrder
    IdCommandes?: SortOrder
  }

  export type inclutMaxOrderByAggregateInput = {
    IdMoto?: SortOrder
    IdCommandes?: SortOrder
  }

  export type inclutMinOrderByAggregateInput = {
    IdMoto?: SortOrder
    IdCommandes?: SortOrder
  }

  export type inclutSumOrderByAggregateInput = {
    IdMoto?: SortOrder
    IdCommandes?: SortOrder
  }

  export type methodedepaiementCountOrderByAggregateInput = {
    IdPaiement?: SortOrder
    TypePaiement?: SortOrder
    InformationsDePaiement?: SortOrder
  }

  export type methodedepaiementAvgOrderByAggregateInput = {
    IdPaiement?: SortOrder
  }

  export type methodedepaiementMaxOrderByAggregateInput = {
    IdPaiement?: SortOrder
    TypePaiement?: SortOrder
    InformationsDePaiement?: SortOrder
  }

  export type methodedepaiementMinOrderByAggregateInput = {
    IdPaiement?: SortOrder
    TypePaiement?: SortOrder
    InformationsDePaiement?: SortOrder
  }

  export type methodedepaiementSumOrderByAggregateInput = {
    IdPaiement?: SortOrder
  }

  export type motosCountOrderByAggregateInput = {
    IdMoto?: SortOrder
    NomMoto?: SortOrder
    Constructeur?: SortOrder
    Modele?: SortOrder
    DescriptionDuProduit?: SortOrder
    Prix?: SortOrder
    Stock?: SortOrder
  }

  export type motosAvgOrderByAggregateInput = {
    IdMoto?: SortOrder
    Prix?: SortOrder
    Stock?: SortOrder
  }

  export type motosMaxOrderByAggregateInput = {
    IdMoto?: SortOrder
    NomMoto?: SortOrder
    Constructeur?: SortOrder
    Modele?: SortOrder
    DescriptionDuProduit?: SortOrder
    Prix?: SortOrder
    Stock?: SortOrder
  }

  export type motosMinOrderByAggregateInput = {
    IdMoto?: SortOrder
    NomMoto?: SortOrder
    Constructeur?: SortOrder
    Modele?: SortOrder
    DescriptionDuProduit?: SortOrder
    Prix?: SortOrder
    Stock?: SortOrder
  }

  export type motosSumOrderByAggregateInput = {
    IdMoto?: SortOrder
    Prix?: SortOrder
    Stock?: SortOrder
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type panierCountOrderByAggregateInput = {
    IdPanier?: SortOrder
    Quantite?: SortOrder
    IdClient?: SortOrder
  }

  export type panierAvgOrderByAggregateInput = {
    IdPanier?: SortOrder
    Quantite?: SortOrder
    IdClient?: SortOrder
  }

  export type panierMaxOrderByAggregateInput = {
    IdPanier?: SortOrder
    Quantite?: SortOrder
    IdClient?: SortOrder
  }

  export type panierMinOrderByAggregateInput = {
    IdPanier?: SortOrder
    Quantite?: SortOrder
    IdClient?: SortOrder
  }

  export type panierSumOrderByAggregateInput = {
    IdPanier?: SortOrder
    Quantite?: SortOrder
    IdClient?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type utiliseIdPaiementIdClientCompoundUniqueInput = {
    IdPaiement: number
    IdClient: number
  }

  export type utiliseCountOrderByAggregateInput = {
    IdPaiement?: SortOrder
    IdClient?: SortOrder
  }

  export type utiliseAvgOrderByAggregateInput = {
    IdPaiement?: SortOrder
    IdClient?: SortOrder
  }

  export type utiliseMaxOrderByAggregateInput = {
    IdPaiement?: SortOrder
    IdClient?: SortOrder
  }

  export type utiliseMinOrderByAggregateInput = {
    IdPaiement?: SortOrder
    IdClient?: SortOrder
  }

  export type utiliseSumOrderByAggregateInput = {
    IdPaiement?: SortOrder
    IdClient?: SortOrder
  }

  export type motossurcommandeCommandeIdMotoIdCompoundUniqueInput = {
    commandeId: number
    motoId: number
  }

  export type motossurcommandeCountOrderByAggregateInput = {
    commandeId?: SortOrder
    motoId?: SortOrder
  }

  export type motossurcommandeAvgOrderByAggregateInput = {
    commandeId?: SortOrder
    motoId?: SortOrder
  }

  export type motossurcommandeMaxOrderByAggregateInput = {
    commandeId?: SortOrder
    motoId?: SortOrder
  }

  export type motossurcommandeMinOrderByAggregateInput = {
    commandeId?: SortOrder
    motoId?: SortOrder
  }

  export type motossurcommandeSumOrderByAggregateInput = {
    commandeId?: SortOrder
    motoId?: SortOrder
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use adresseDefaultArgs instead
     */
    export type adresseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = adresseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use choisitDefaultArgs instead
     */
    export type choisitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = choisitDefaultArgs<ExtArgs>
    /**
     * @deprecated Use clientDefaultArgs instead
     */
    export type clientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = clientDefaultArgs<ExtArgs>
    /**
     * @deprecated Use commandeDefaultArgs instead
     */
    export type commandeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = commandeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use factureDefaultArgs instead
     */
    export type factureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = factureDefaultArgs<ExtArgs>
    /**
     * @deprecated Use inclutDefaultArgs instead
     */
    export type inclutArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = inclutDefaultArgs<ExtArgs>
    /**
     * @deprecated Use methodedepaiementDefaultArgs instead
     */
    export type methodedepaiementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = methodedepaiementDefaultArgs<ExtArgs>
    /**
     * @deprecated Use motosDefaultArgs instead
     */
    export type motosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = motosDefaultArgs<ExtArgs>
    /**
     * @deprecated Use panierDefaultArgs instead
     */
    export type panierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = panierDefaultArgs<ExtArgs>
    /**
     * @deprecated Use utiliseDefaultArgs instead
     */
    export type utiliseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = utiliseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use motossurcommandeDefaultArgs instead
     */
    export type motossurcommandeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = motossurcommandeDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}